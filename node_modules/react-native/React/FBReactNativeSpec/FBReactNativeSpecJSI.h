/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


template <typename T>
class JSI_EXPORT NativeDevMenuCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "DevMenu";

protected:
  NativeDevMenuCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDevMenuCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["show"] = MethodMetadata {.argCount = 0, .invoker = __show};
    methodMap_["reload"] = MethodMetadata {.argCount = 0, .invoker = __reload};
    methodMap_["setProfilingEnabled"] = MethodMetadata {.argCount = 1, .invoker = __setProfilingEnabled};
    methodMap_["setHotLoadingEnabled"] = MethodMetadata {.argCount = 1, .invoker = __setHotLoadingEnabled};
  }
  
private:
  static jsi::Value __show(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::show) == 1,
      "Expected show(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::show,  static_cast<NativeDevMenuCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __reload(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::reload) == 1,
      "Expected reload(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::reload,  static_cast<NativeDevMenuCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __setProfilingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setProfilingEnabled) == 2,
      "Expected setProfilingEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setProfilingEnabled,  static_cast<NativeDevMenuCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __setHotLoadingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
      "Expected setHotLoadingEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setHotLoadingEnabled,  static_cast<NativeDevMenuCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }
};


#pragma mark - NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfig

template <typename P0, typename P1>
struct NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfig {
  P0 shouldReloadAndProfile;
  P1 recordChangeDescriptions;
  bool operator==(const NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfig &other) const {
    return shouldReloadAndProfile == other.shouldReloadAndProfile && recordChangeDescriptions == other.recordChangeDescriptions;
  }
};

template <typename T>
struct NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfigBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.shouldReloadAndProfile)>(rt, value.getProperty(rt, "shouldReloadAndProfile"), jsInvoker),
      bridging::fromJs<decltype(types.recordChangeDescriptions)>(rt, value.getProperty(rt, "recordChangeDescriptions"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool shouldReloadAndProfileToJs(jsi::Runtime &rt, decltype(types.shouldReloadAndProfile) value) {
    return bridging::toJs(rt, value);
  }
  static bool recordChangeDescriptionsToJs(jsi::Runtime &rt, decltype(types.recordChangeDescriptions) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.shouldReloadAndProfile) {
      result.setProperty(rt, "shouldReloadAndProfile", bridging::toJs(rt, value.shouldReloadAndProfile.value(), jsInvoker));
    }
    if (value.recordChangeDescriptions) {
      result.setProperty(rt, "recordChangeDescriptions", bridging::toJs(rt, value.recordChangeDescriptions.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfig

template <typename P0, typename P1>
struct NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfig {
  P0 shouldReloadAndProfile;
  P1 recordChangeDescriptions;
  bool operator==(const NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfig &other) const {
    return shouldReloadAndProfile == other.shouldReloadAndProfile && recordChangeDescriptions == other.recordChangeDescriptions;
  }
};

template <typename T>
struct NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfigBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.shouldReloadAndProfile)>(rt, value.getProperty(rt, "shouldReloadAndProfile"), jsInvoker),
      bridging::fromJs<decltype(types.recordChangeDescriptions)>(rt, value.getProperty(rt, "recordChangeDescriptions"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool shouldReloadAndProfileToJs(jsi::Runtime &rt, decltype(types.shouldReloadAndProfile) value) {
    return bridging::toJs(rt, value);
  }
  static bool recordChangeDescriptionsToJs(jsi::Runtime &rt, decltype(types.recordChangeDescriptions) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "shouldReloadAndProfile", bridging::toJs(rt, value.shouldReloadAndProfile, jsInvoker));
    result.setProperty(rt, "recordChangeDescriptions", bridging::toJs(rt, value.recordChangeDescriptions, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeReactDevToolsRuntimeSettingsModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ReactDevToolsRuntimeSettingsModule";

protected:
  NativeReactDevToolsRuntimeSettingsModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeReactDevToolsRuntimeSettingsModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["setReloadAndProfileConfig"] = MethodMetadata {.argCount = 1, .invoker = __setReloadAndProfileConfig};
    methodMap_["getReloadAndProfileConfig"] = MethodMetadata {.argCount = 0, .invoker = __getReloadAndProfileConfig};
  }
  
private:
  static jsi::Value __setReloadAndProfileConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setReloadAndProfileConfig) == 2,
      "Expected setReloadAndProfileConfig(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setReloadAndProfileConfig,  static_cast<NativeReactDevToolsRuntimeSettingsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getReloadAndProfileConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getReloadAndProfileConfig) == 1,
      "Expected getReloadAndProfileConfig(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getReloadAndProfileConfig,  static_cast<NativeReactDevToolsRuntimeSettingsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeReactDevToolsSettingsManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ReactDevToolsSettingsManager";

protected:
  NativeReactDevToolsSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeReactDevToolsSettingsManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["setGlobalHookSettings"] = MethodMetadata {.argCount = 1, .invoker = __setGlobalHookSettings};
    methodMap_["getGlobalHookSettings"] = MethodMetadata {.argCount = 0, .invoker = __getGlobalHookSettings};
  }
  
private:
  static jsi::Value __setGlobalHookSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setGlobalHookSettings) == 2,
      "Expected setGlobalHookSettings(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setGlobalHookSettings,  static_cast<NativeReactDevToolsSettingsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getGlobalHookSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getGlobalHookSettings) == 1,
      "Expected getGlobalHookSettings(...) to have 1 parameters");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getGlobalHookSettings,  static_cast<NativeReactDevToolsSettingsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }
};


template <typename T>
class JSI_EXPORT NativeReactNativeFeatureFlagsCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeReactNativeFeatureFlagsCxx";

protected:
  NativeReactNativeFeatureFlagsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeReactNativeFeatureFlagsCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["commonTestFlag"] = MethodMetadata {.argCount = 0, .invoker = __commonTestFlag};
    methodMap_["commonTestFlagWithoutNativeImplementation"] = MethodMetadata {.argCount = 0, .invoker = __commonTestFlagWithoutNativeImplementation};
    methodMap_["cdpInteractionMetricsEnabled"] = MethodMetadata {.argCount = 0, .invoker = __cdpInteractionMetricsEnabled};
    methodMap_["cxxNativeAnimatedEnabled"] = MethodMetadata {.argCount = 0, .invoker = __cxxNativeAnimatedEnabled};
    methodMap_["cxxNativeAnimatedRemoveJsSync"] = MethodMetadata {.argCount = 0, .invoker = __cxxNativeAnimatedRemoveJsSync};
    methodMap_["disableEarlyViewCommandExecution"] = MethodMetadata {.argCount = 0, .invoker = __disableEarlyViewCommandExecution};
    methodMap_["disableFabricCommitInCXXAnimated"] = MethodMetadata {.argCount = 0, .invoker = __disableFabricCommitInCXXAnimated};
    methodMap_["disableMountItemReorderingAndroid"] = MethodMetadata {.argCount = 0, .invoker = __disableMountItemReorderingAndroid};
    methodMap_["disableOldAndroidAttachmentMetricsWorkarounds"] = MethodMetadata {.argCount = 0, .invoker = __disableOldAndroidAttachmentMetricsWorkarounds};
    methodMap_["disableTextLayoutManagerCacheAndroid"] = MethodMetadata {.argCount = 0, .invoker = __disableTextLayoutManagerCacheAndroid};
    methodMap_["enableAccessibilityOrder"] = MethodMetadata {.argCount = 0, .invoker = __enableAccessibilityOrder};
    methodMap_["enableAccumulatedUpdatesInRawPropsAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enableAccumulatedUpdatesInRawPropsAndroid};
    methodMap_["enableAndroidLinearText"] = MethodMetadata {.argCount = 0, .invoker = __enableAndroidLinearText};
    methodMap_["enableAndroidTextMeasurementOptimizations"] = MethodMetadata {.argCount = 0, .invoker = __enableAndroidTextMeasurementOptimizations};
    methodMap_["enableBridgelessArchitecture"] = MethodMetadata {.argCount = 0, .invoker = __enableBridgelessArchitecture};
    methodMap_["enableCppPropsIteratorSetter"] = MethodMetadata {.argCount = 0, .invoker = __enableCppPropsIteratorSetter};
    methodMap_["enableCustomFocusSearchOnClippedElementsAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enableCustomFocusSearchOnClippedElementsAndroid};
    methodMap_["enableDestroyShadowTreeRevisionAsync"] = MethodMetadata {.argCount = 0, .invoker = __enableDestroyShadowTreeRevisionAsync};
    methodMap_["enableDoubleMeasurementFixAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enableDoubleMeasurementFixAndroid};
    methodMap_["enableEagerMainQueueModulesOnIOS"] = MethodMetadata {.argCount = 0, .invoker = __enableEagerMainQueueModulesOnIOS};
    methodMap_["enableEagerRootViewAttachment"] = MethodMetadata {.argCount = 0, .invoker = __enableEagerRootViewAttachment};
    methodMap_["enableFabricLogs"] = MethodMetadata {.argCount = 0, .invoker = __enableFabricLogs};
    methodMap_["enableFabricRenderer"] = MethodMetadata {.argCount = 0, .invoker = __enableFabricRenderer};
    methodMap_["enableFontScaleChangesUpdatingLayout"] = MethodMetadata {.argCount = 0, .invoker = __enableFontScaleChangesUpdatingLayout};
    methodMap_["enableIOSTextBaselineOffsetPerLine"] = MethodMetadata {.argCount = 0, .invoker = __enableIOSTextBaselineOffsetPerLine};
    methodMap_["enableIOSViewClipToPaddingBox"] = MethodMetadata {.argCount = 0, .invoker = __enableIOSViewClipToPaddingBox};
    methodMap_["enableImagePrefetchingAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enableImagePrefetchingAndroid};
    methodMap_["enableImagePrefetchingOnUiThreadAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enableImagePrefetchingOnUiThreadAndroid};
    methodMap_["enableImmediateUpdateModeForContentOffsetChanges"] = MethodMetadata {.argCount = 0, .invoker = __enableImmediateUpdateModeForContentOffsetChanges};
    methodMap_["enableImperativeFocus"] = MethodMetadata {.argCount = 0, .invoker = __enableImperativeFocus};
    methodMap_["enableInteropViewManagerClassLookUpOptimizationIOS"] = MethodMetadata {.argCount = 0, .invoker = __enableInteropViewManagerClassLookUpOptimizationIOS};
    methodMap_["enableIntersectionObserverByDefault"] = MethodMetadata {.argCount = 0, .invoker = __enableIntersectionObserverByDefault};
    methodMap_["enableKeyEvents"] = MethodMetadata {.argCount = 0, .invoker = __enableKeyEvents};
    methodMap_["enableLayoutAnimationsOnAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enableLayoutAnimationsOnAndroid};
    methodMap_["enableLayoutAnimationsOnIOS"] = MethodMetadata {.argCount = 0, .invoker = __enableLayoutAnimationsOnIOS};
    methodMap_["enableMainQueueCoordinatorOnIOS"] = MethodMetadata {.argCount = 0, .invoker = __enableMainQueueCoordinatorOnIOS};
    methodMap_["enableModuleArgumentNSNullConversionIOS"] = MethodMetadata {.argCount = 0, .invoker = __enableModuleArgumentNSNullConversionIOS};
    methodMap_["enableNativeCSSParsing"] = MethodMetadata {.argCount = 0, .invoker = __enableNativeCSSParsing};
    methodMap_["enableNetworkEventReporting"] = MethodMetadata {.argCount = 0, .invoker = __enableNetworkEventReporting};
    methodMap_["enablePreparedTextLayout"] = MethodMetadata {.argCount = 0, .invoker = __enablePreparedTextLayout};
    methodMap_["enablePropsUpdateReconciliationAndroid"] = MethodMetadata {.argCount = 0, .invoker = __enablePropsUpdateReconciliationAndroid};
    methodMap_["enableResourceTimingAPI"] = MethodMetadata {.argCount = 0, .invoker = __enableResourceTimingAPI};
    methodMap_["enableSwiftUIBasedFilters"] = MethodMetadata {.argCount = 0, .invoker = __enableSwiftUIBasedFilters};
    methodMap_["enableViewCulling"] = MethodMetadata {.argCount = 0, .invoker = __enableViewCulling};
    methodMap_["enableViewRecycling"] = MethodMetadata {.argCount = 0, .invoker = __enableViewRecycling};
    methodMap_["enableViewRecyclingForImage"] = MethodMetadata {.argCount = 0, .invoker = __enableViewRecyclingForImage};
    methodMap_["enableViewRecyclingForScrollView"] = MethodMetadata {.argCount = 0, .invoker = __enableViewRecyclingForScrollView};
    methodMap_["enableViewRecyclingForText"] = MethodMetadata {.argCount = 0, .invoker = __enableViewRecyclingForText};
    methodMap_["enableViewRecyclingForView"] = MethodMetadata {.argCount = 0, .invoker = __enableViewRecyclingForView};
    methodMap_["enableVirtualViewClippingWithoutScrollViewClipping"] = MethodMetadata {.argCount = 0, .invoker = __enableVirtualViewClippingWithoutScrollViewClipping};
    methodMap_["enableVirtualViewContainerStateExperimental"] = MethodMetadata {.argCount = 0, .invoker = __enableVirtualViewContainerStateExperimental};
    methodMap_["enableVirtualViewDebugFeatures"] = MethodMetadata {.argCount = 0, .invoker = __enableVirtualViewDebugFeatures};
    methodMap_["enableVirtualViewRenderState"] = MethodMetadata {.argCount = 0, .invoker = __enableVirtualViewRenderState};
    methodMap_["enableVirtualViewWindowFocusDetection"] = MethodMetadata {.argCount = 0, .invoker = __enableVirtualViewWindowFocusDetection};
    methodMap_["enableWebPerformanceAPIsByDefault"] = MethodMetadata {.argCount = 0, .invoker = __enableWebPerformanceAPIsByDefault};
    methodMap_["fixMappingOfEventPrioritiesBetweenFabricAndReact"] = MethodMetadata {.argCount = 0, .invoker = __fixMappingOfEventPrioritiesBetweenFabricAndReact};
    methodMap_["fuseboxAssertSingleHostState"] = MethodMetadata {.argCount = 0, .invoker = __fuseboxAssertSingleHostState};
    methodMap_["fuseboxEnabledRelease"] = MethodMetadata {.argCount = 0, .invoker = __fuseboxEnabledRelease};
    methodMap_["fuseboxNetworkInspectionEnabled"] = MethodMetadata {.argCount = 0, .invoker = __fuseboxNetworkInspectionEnabled};
    methodMap_["hideOffscreenVirtualViewsOnIOS"] = MethodMetadata {.argCount = 0, .invoker = __hideOffscreenVirtualViewsOnIOS};
    methodMap_["overrideBySynchronousMountPropsAtMountingAndroid"] = MethodMetadata {.argCount = 0, .invoker = __overrideBySynchronousMountPropsAtMountingAndroid};
    methodMap_["perfIssuesEnabled"] = MethodMetadata {.argCount = 0, .invoker = __perfIssuesEnabled};
    methodMap_["perfMonitorV2Enabled"] = MethodMetadata {.argCount = 0, .invoker = __perfMonitorV2Enabled};
    methodMap_["preparedTextCacheSize"] = MethodMetadata {.argCount = 0, .invoker = __preparedTextCacheSize};
    methodMap_["preventShadowTreeCommitExhaustion"] = MethodMetadata {.argCount = 0, .invoker = __preventShadowTreeCommitExhaustion};
    methodMap_["shouldPressibilityUseW3CPointerEventsForHover"] = MethodMetadata {.argCount = 0, .invoker = __shouldPressibilityUseW3CPointerEventsForHover};
    methodMap_["shouldTriggerResponderTransferOnScrollAndroid"] = MethodMetadata {.argCount = 0, .invoker = __shouldTriggerResponderTransferOnScrollAndroid};
    methodMap_["skipActivityIdentityAssertionOnHostPause"] = MethodMetadata {.argCount = 0, .invoker = __skipActivityIdentityAssertionOnHostPause};
    methodMap_["sweepActiveTouchOnChildNativeGesturesAndroid"] = MethodMetadata {.argCount = 0, .invoker = __sweepActiveTouchOnChildNativeGesturesAndroid};
    methodMap_["traceTurboModulePromiseRejectionsOnAndroid"] = MethodMetadata {.argCount = 0, .invoker = __traceTurboModulePromiseRejectionsOnAndroid};
    methodMap_["updateRuntimeShadowNodeReferencesOnCommit"] = MethodMetadata {.argCount = 0, .invoker = __updateRuntimeShadowNodeReferencesOnCommit};
    methodMap_["useAlwaysAvailableJSErrorHandling"] = MethodMetadata {.argCount = 0, .invoker = __useAlwaysAvailableJSErrorHandling};
    methodMap_["useFabricInterop"] = MethodMetadata {.argCount = 0, .invoker = __useFabricInterop};
    methodMap_["useNativeEqualsInNativeReadableArrayAndroid"] = MethodMetadata {.argCount = 0, .invoker = __useNativeEqualsInNativeReadableArrayAndroid};
    methodMap_["useNativeTransformHelperAndroid"] = MethodMetadata {.argCount = 0, .invoker = __useNativeTransformHelperAndroid};
    methodMap_["useNativeViewConfigsInBridgelessMode"] = MethodMetadata {.argCount = 0, .invoker = __useNativeViewConfigsInBridgelessMode};
    methodMap_["useOptimizedEventBatchingOnAndroid"] = MethodMetadata {.argCount = 0, .invoker = __useOptimizedEventBatchingOnAndroid};
    methodMap_["useRawPropsJsiValue"] = MethodMetadata {.argCount = 0, .invoker = __useRawPropsJsiValue};
    methodMap_["useShadowNodeStateOnClone"] = MethodMetadata {.argCount = 0, .invoker = __useShadowNodeStateOnClone};
    methodMap_["useSharedAnimatedBackend"] = MethodMetadata {.argCount = 0, .invoker = __useSharedAnimatedBackend};
    methodMap_["useTraitHiddenOnAndroid"] = MethodMetadata {.argCount = 0, .invoker = __useTraitHiddenOnAndroid};
    methodMap_["useTurboModuleInterop"] = MethodMetadata {.argCount = 0, .invoker = __useTurboModuleInterop};
    methodMap_["useTurboModules"] = MethodMetadata {.argCount = 0, .invoker = __useTurboModules};
    methodMap_["viewCullingOutsetRatio"] = MethodMetadata {.argCount = 0, .invoker = __viewCullingOutsetRatio};
    methodMap_["virtualViewHysteresisRatio"] = MethodMetadata {.argCount = 0, .invoker = __virtualViewHysteresisRatio};
    methodMap_["virtualViewPrerenderRatio"] = MethodMetadata {.argCount = 0, .invoker = __virtualViewPrerenderRatio};
  }
  
private:
  static jsi::Value __commonTestFlag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::commonTestFlag) == 1,
      "Expected commonTestFlag(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::commonTestFlag,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __commonTestFlagWithoutNativeImplementation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::commonTestFlagWithoutNativeImplementation) == 1,
      "Expected commonTestFlagWithoutNativeImplementation(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::commonTestFlagWithoutNativeImplementation,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __cdpInteractionMetricsEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::cdpInteractionMetricsEnabled) == 1,
      "Expected cdpInteractionMetricsEnabled(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::cdpInteractionMetricsEnabled,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __cxxNativeAnimatedEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::cxxNativeAnimatedEnabled) == 1,
      "Expected cxxNativeAnimatedEnabled(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::cxxNativeAnimatedEnabled,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __cxxNativeAnimatedRemoveJsSync(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::cxxNativeAnimatedRemoveJsSync) == 1,
      "Expected cxxNativeAnimatedRemoveJsSync(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::cxxNativeAnimatedRemoveJsSync,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __disableEarlyViewCommandExecution(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disableEarlyViewCommandExecution) == 1,
      "Expected disableEarlyViewCommandExecution(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::disableEarlyViewCommandExecution,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __disableFabricCommitInCXXAnimated(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disableFabricCommitInCXXAnimated) == 1,
      "Expected disableFabricCommitInCXXAnimated(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::disableFabricCommitInCXXAnimated,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __disableMountItemReorderingAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disableMountItemReorderingAndroid) == 1,
      "Expected disableMountItemReorderingAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::disableMountItemReorderingAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __disableOldAndroidAttachmentMetricsWorkarounds(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disableOldAndroidAttachmentMetricsWorkarounds) == 1,
      "Expected disableOldAndroidAttachmentMetricsWorkarounds(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::disableOldAndroidAttachmentMetricsWorkarounds,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __disableTextLayoutManagerCacheAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disableTextLayoutManagerCacheAndroid) == 1,
      "Expected disableTextLayoutManagerCacheAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::disableTextLayoutManagerCacheAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableAccessibilityOrder(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableAccessibilityOrder) == 1,
      "Expected enableAccessibilityOrder(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableAccessibilityOrder,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableAccumulatedUpdatesInRawPropsAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableAccumulatedUpdatesInRawPropsAndroid) == 1,
      "Expected enableAccumulatedUpdatesInRawPropsAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableAccumulatedUpdatesInRawPropsAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableAndroidLinearText(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableAndroidLinearText) == 1,
      "Expected enableAndroidLinearText(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableAndroidLinearText,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableAndroidTextMeasurementOptimizations(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableAndroidTextMeasurementOptimizations) == 1,
      "Expected enableAndroidTextMeasurementOptimizations(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableAndroidTextMeasurementOptimizations,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableBridgelessArchitecture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableBridgelessArchitecture) == 1,
      "Expected enableBridgelessArchitecture(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableBridgelessArchitecture,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableCppPropsIteratorSetter(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableCppPropsIteratorSetter) == 1,
      "Expected enableCppPropsIteratorSetter(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableCppPropsIteratorSetter,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableCustomFocusSearchOnClippedElementsAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableCustomFocusSearchOnClippedElementsAndroid) == 1,
      "Expected enableCustomFocusSearchOnClippedElementsAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableCustomFocusSearchOnClippedElementsAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableDestroyShadowTreeRevisionAsync(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableDestroyShadowTreeRevisionAsync) == 1,
      "Expected enableDestroyShadowTreeRevisionAsync(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableDestroyShadowTreeRevisionAsync,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableDoubleMeasurementFixAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableDoubleMeasurementFixAndroid) == 1,
      "Expected enableDoubleMeasurementFixAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableDoubleMeasurementFixAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableEagerMainQueueModulesOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableEagerMainQueueModulesOnIOS) == 1,
      "Expected enableEagerMainQueueModulesOnIOS(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableEagerMainQueueModulesOnIOS,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableEagerRootViewAttachment(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableEagerRootViewAttachment) == 1,
      "Expected enableEagerRootViewAttachment(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableEagerRootViewAttachment,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableFabricLogs(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableFabricLogs) == 1,
      "Expected enableFabricLogs(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableFabricLogs,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableFabricRenderer(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableFabricRenderer) == 1,
      "Expected enableFabricRenderer(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableFabricRenderer,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableFontScaleChangesUpdatingLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableFontScaleChangesUpdatingLayout) == 1,
      "Expected enableFontScaleChangesUpdatingLayout(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableFontScaleChangesUpdatingLayout,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableIOSTextBaselineOffsetPerLine(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableIOSTextBaselineOffsetPerLine) == 1,
      "Expected enableIOSTextBaselineOffsetPerLine(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableIOSTextBaselineOffsetPerLine,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableIOSViewClipToPaddingBox(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableIOSViewClipToPaddingBox) == 1,
      "Expected enableIOSViewClipToPaddingBox(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableIOSViewClipToPaddingBox,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableImagePrefetchingAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableImagePrefetchingAndroid) == 1,
      "Expected enableImagePrefetchingAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableImagePrefetchingAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableImagePrefetchingOnUiThreadAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableImagePrefetchingOnUiThreadAndroid) == 1,
      "Expected enableImagePrefetchingOnUiThreadAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableImagePrefetchingOnUiThreadAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableImmediateUpdateModeForContentOffsetChanges(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableImmediateUpdateModeForContentOffsetChanges) == 1,
      "Expected enableImmediateUpdateModeForContentOffsetChanges(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableImmediateUpdateModeForContentOffsetChanges,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableImperativeFocus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableImperativeFocus) == 1,
      "Expected enableImperativeFocus(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableImperativeFocus,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableInteropViewManagerClassLookUpOptimizationIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableInteropViewManagerClassLookUpOptimizationIOS) == 1,
      "Expected enableInteropViewManagerClassLookUpOptimizationIOS(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableInteropViewManagerClassLookUpOptimizationIOS,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableIntersectionObserverByDefault(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableIntersectionObserverByDefault) == 1,
      "Expected enableIntersectionObserverByDefault(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableIntersectionObserverByDefault,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableKeyEvents(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableKeyEvents) == 1,
      "Expected enableKeyEvents(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableKeyEvents,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableLayoutAnimationsOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableLayoutAnimationsOnAndroid) == 1,
      "Expected enableLayoutAnimationsOnAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableLayoutAnimationsOnAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableLayoutAnimationsOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableLayoutAnimationsOnIOS) == 1,
      "Expected enableLayoutAnimationsOnIOS(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableLayoutAnimationsOnIOS,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableMainQueueCoordinatorOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableMainQueueCoordinatorOnIOS) == 1,
      "Expected enableMainQueueCoordinatorOnIOS(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableMainQueueCoordinatorOnIOS,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableModuleArgumentNSNullConversionIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableModuleArgumentNSNullConversionIOS) == 1,
      "Expected enableModuleArgumentNSNullConversionIOS(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableModuleArgumentNSNullConversionIOS,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableNativeCSSParsing(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableNativeCSSParsing) == 1,
      "Expected enableNativeCSSParsing(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableNativeCSSParsing,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableNetworkEventReporting(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableNetworkEventReporting) == 1,
      "Expected enableNetworkEventReporting(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableNetworkEventReporting,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enablePreparedTextLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enablePreparedTextLayout) == 1,
      "Expected enablePreparedTextLayout(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enablePreparedTextLayout,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enablePropsUpdateReconciliationAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enablePropsUpdateReconciliationAndroid) == 1,
      "Expected enablePropsUpdateReconciliationAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enablePropsUpdateReconciliationAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableResourceTimingAPI(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableResourceTimingAPI) == 1,
      "Expected enableResourceTimingAPI(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableResourceTimingAPI,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableSwiftUIBasedFilters(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableSwiftUIBasedFilters) == 1,
      "Expected enableSwiftUIBasedFilters(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableSwiftUIBasedFilters,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableViewCulling(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableViewCulling) == 1,
      "Expected enableViewCulling(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableViewCulling,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableViewRecycling(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableViewRecycling) == 1,
      "Expected enableViewRecycling(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableViewRecycling,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableViewRecyclingForImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableViewRecyclingForImage) == 1,
      "Expected enableViewRecyclingForImage(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableViewRecyclingForImage,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableViewRecyclingForScrollView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableViewRecyclingForScrollView) == 1,
      "Expected enableViewRecyclingForScrollView(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableViewRecyclingForScrollView,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableViewRecyclingForText(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableViewRecyclingForText) == 1,
      "Expected enableViewRecyclingForText(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableViewRecyclingForText,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableViewRecyclingForView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableViewRecyclingForView) == 1,
      "Expected enableViewRecyclingForView(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableViewRecyclingForView,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableVirtualViewClippingWithoutScrollViewClipping(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableVirtualViewClippingWithoutScrollViewClipping) == 1,
      "Expected enableVirtualViewClippingWithoutScrollViewClipping(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableVirtualViewClippingWithoutScrollViewClipping,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableVirtualViewContainerStateExperimental(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableVirtualViewContainerStateExperimental) == 1,
      "Expected enableVirtualViewContainerStateExperimental(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableVirtualViewContainerStateExperimental,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableVirtualViewDebugFeatures(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableVirtualViewDebugFeatures) == 1,
      "Expected enableVirtualViewDebugFeatures(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableVirtualViewDebugFeatures,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableVirtualViewRenderState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableVirtualViewRenderState) == 1,
      "Expected enableVirtualViewRenderState(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableVirtualViewRenderState,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableVirtualViewWindowFocusDetection(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableVirtualViewWindowFocusDetection) == 1,
      "Expected enableVirtualViewWindowFocusDetection(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableVirtualViewWindowFocusDetection,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __enableWebPerformanceAPIsByDefault(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::enableWebPerformanceAPIsByDefault) == 1,
      "Expected enableWebPerformanceAPIsByDefault(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::enableWebPerformanceAPIsByDefault,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __fixMappingOfEventPrioritiesBetweenFabricAndReact(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::fixMappingOfEventPrioritiesBetweenFabricAndReact) == 1,
      "Expected fixMappingOfEventPrioritiesBetweenFabricAndReact(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::fixMappingOfEventPrioritiesBetweenFabricAndReact,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __fuseboxAssertSingleHostState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::fuseboxAssertSingleHostState) == 1,
      "Expected fuseboxAssertSingleHostState(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::fuseboxAssertSingleHostState,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __fuseboxEnabledRelease(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::fuseboxEnabledRelease) == 1,
      "Expected fuseboxEnabledRelease(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::fuseboxEnabledRelease,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __fuseboxNetworkInspectionEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::fuseboxNetworkInspectionEnabled) == 1,
      "Expected fuseboxNetworkInspectionEnabled(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::fuseboxNetworkInspectionEnabled,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __hideOffscreenVirtualViewsOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::hideOffscreenVirtualViewsOnIOS) == 1,
      "Expected hideOffscreenVirtualViewsOnIOS(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::hideOffscreenVirtualViewsOnIOS,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __overrideBySynchronousMountPropsAtMountingAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::overrideBySynchronousMountPropsAtMountingAndroid) == 1,
      "Expected overrideBySynchronousMountPropsAtMountingAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::overrideBySynchronousMountPropsAtMountingAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __perfIssuesEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::perfIssuesEnabled) == 1,
      "Expected perfIssuesEnabled(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::perfIssuesEnabled,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __perfMonitorV2Enabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::perfMonitorV2Enabled) == 1,
      "Expected perfMonitorV2Enabled(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::perfMonitorV2Enabled,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __preparedTextCacheSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::preparedTextCacheSize) == 1,
      "Expected preparedTextCacheSize(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::preparedTextCacheSize,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __preventShadowTreeCommitExhaustion(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::preventShadowTreeCommitExhaustion) == 1,
      "Expected preventShadowTreeCommitExhaustion(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::preventShadowTreeCommitExhaustion,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __shouldPressibilityUseW3CPointerEventsForHover(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::shouldPressibilityUseW3CPointerEventsForHover) == 1,
      "Expected shouldPressibilityUseW3CPointerEventsForHover(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::shouldPressibilityUseW3CPointerEventsForHover,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __shouldTriggerResponderTransferOnScrollAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::shouldTriggerResponderTransferOnScrollAndroid) == 1,
      "Expected shouldTriggerResponderTransferOnScrollAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::shouldTriggerResponderTransferOnScrollAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __skipActivityIdentityAssertionOnHostPause(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::skipActivityIdentityAssertionOnHostPause) == 1,
      "Expected skipActivityIdentityAssertionOnHostPause(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::skipActivityIdentityAssertionOnHostPause,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __sweepActiveTouchOnChildNativeGesturesAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::sweepActiveTouchOnChildNativeGesturesAndroid) == 1,
      "Expected sweepActiveTouchOnChildNativeGesturesAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::sweepActiveTouchOnChildNativeGesturesAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __traceTurboModulePromiseRejectionsOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::traceTurboModulePromiseRejectionsOnAndroid) == 1,
      "Expected traceTurboModulePromiseRejectionsOnAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::traceTurboModulePromiseRejectionsOnAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __updateRuntimeShadowNodeReferencesOnCommit(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::updateRuntimeShadowNodeReferencesOnCommit) == 1,
      "Expected updateRuntimeShadowNodeReferencesOnCommit(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::updateRuntimeShadowNodeReferencesOnCommit,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useAlwaysAvailableJSErrorHandling(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useAlwaysAvailableJSErrorHandling) == 1,
      "Expected useAlwaysAvailableJSErrorHandling(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useAlwaysAvailableJSErrorHandling,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useFabricInterop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useFabricInterop) == 1,
      "Expected useFabricInterop(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useFabricInterop,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useNativeEqualsInNativeReadableArrayAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useNativeEqualsInNativeReadableArrayAndroid) == 1,
      "Expected useNativeEqualsInNativeReadableArrayAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useNativeEqualsInNativeReadableArrayAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useNativeTransformHelperAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useNativeTransformHelperAndroid) == 1,
      "Expected useNativeTransformHelperAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useNativeTransformHelperAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useNativeViewConfigsInBridgelessMode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useNativeViewConfigsInBridgelessMode) == 1,
      "Expected useNativeViewConfigsInBridgelessMode(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useNativeViewConfigsInBridgelessMode,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useOptimizedEventBatchingOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useOptimizedEventBatchingOnAndroid) == 1,
      "Expected useOptimizedEventBatchingOnAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useOptimizedEventBatchingOnAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useRawPropsJsiValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useRawPropsJsiValue) == 1,
      "Expected useRawPropsJsiValue(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useRawPropsJsiValue,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useShadowNodeStateOnClone(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useShadowNodeStateOnClone) == 1,
      "Expected useShadowNodeStateOnClone(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useShadowNodeStateOnClone,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useSharedAnimatedBackend(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useSharedAnimatedBackend) == 1,
      "Expected useSharedAnimatedBackend(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useSharedAnimatedBackend,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useTraitHiddenOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useTraitHiddenOnAndroid) == 1,
      "Expected useTraitHiddenOnAndroid(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useTraitHiddenOnAndroid,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useTurboModuleInterop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useTurboModuleInterop) == 1,
      "Expected useTurboModuleInterop(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useTurboModuleInterop,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __useTurboModules(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::useTurboModules) == 1,
      "Expected useTurboModules(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::useTurboModules,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __viewCullingOutsetRatio(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::viewCullingOutsetRatio) == 1,
      "Expected viewCullingOutsetRatio(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::viewCullingOutsetRatio,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __virtualViewHysteresisRatio(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::virtualViewHysteresisRatio) == 1,
      "Expected virtualViewHysteresisRatio(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::virtualViewHysteresisRatio,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __virtualViewPrerenderRatio(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::virtualViewPrerenderRatio) == 1,
      "Expected virtualViewPrerenderRatio(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::virtualViewPrerenderRatio,  static_cast<NativeReactNativeFeatureFlagsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeAccessibilityInfoCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "AccessibilityInfo";

protected:
  NativeAccessibilityInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAccessibilityInfoCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["isReduceMotionEnabled"] = MethodMetadata {.argCount = 1, .invoker = __isReduceMotionEnabled};
    methodMap_["isInvertColorsEnabled"] = MethodMetadata {.argCount = 1, .invoker = __isInvertColorsEnabled};
    methodMap_["isHighTextContrastEnabled"] = MethodMetadata {.argCount = 1, .invoker = __isHighTextContrastEnabled};
    methodMap_["isTouchExplorationEnabled"] = MethodMetadata {.argCount = 1, .invoker = __isTouchExplorationEnabled};
    methodMap_["isAccessibilityServiceEnabled"] = MethodMetadata {.argCount = 1, .invoker = __isAccessibilityServiceEnabled};
    methodMap_["setAccessibilityFocus"] = MethodMetadata {.argCount = 1, .invoker = __setAccessibilityFocus};
    methodMap_["announceForAccessibility"] = MethodMetadata {.argCount = 1, .invoker = __announceForAccessibility};
    methodMap_["getRecommendedTimeoutMillis"] = MethodMetadata {.argCount = 2, .invoker = __getRecommendedTimeoutMillis};
    methodMap_["isGrayscaleEnabled"] = MethodMetadata {.argCount = 1, .invoker = __isGrayscaleEnabled};
  }
  
private:
  static jsi::Value __isReduceMotionEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isReduceMotionEnabled) == 2,
      "Expected isReduceMotionEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::isReduceMotionEnabled,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __isInvertColorsEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isInvertColorsEnabled) == 2,
      "Expected isInvertColorsEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::isInvertColorsEnabled,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __isHighTextContrastEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isHighTextContrastEnabled) == 2,
      "Expected isHighTextContrastEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::isHighTextContrastEnabled,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __isTouchExplorationEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isTouchExplorationEnabled) == 2,
      "Expected isTouchExplorationEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::isTouchExplorationEnabled,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __isAccessibilityServiceEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isAccessibilityServiceEnabled) == 2,
      "Expected isAccessibilityServiceEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::isAccessibilityServiceEnabled,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setAccessibilityFocus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
      "Expected setAccessibilityFocus(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setAccessibilityFocus,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __announceForAccessibility(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::announceForAccessibility) == 2,
      "Expected announceForAccessibility(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::announceForAccessibility,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getRecommendedTimeoutMillis(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRecommendedTimeoutMillis) == 3,
      "Expected getRecommendedTimeoutMillis(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getRecommendedTimeoutMillis,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __isGrayscaleEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isGrayscaleEnabled) == 2,
      "Expected isGrayscaleEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::isGrayscaleEnabled,  static_cast<NativeAccessibilityInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeAccessibilityManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "AccessibilityManager";

protected:
  NativeAccessibilityManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAccessibilityManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getCurrentBoldTextState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentBoldTextState};
    methodMap_["getCurrentGrayscaleState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentGrayscaleState};
    methodMap_["getCurrentInvertColorsState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentInvertColorsState};
    methodMap_["getCurrentReduceMotionState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentReduceMotionState};
    methodMap_["getCurrentDarkerSystemColorsState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentDarkerSystemColorsState};
    methodMap_["getCurrentPrefersCrossFadeTransitionsState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentPrefersCrossFadeTransitionsState};
    methodMap_["getCurrentReduceTransparencyState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentReduceTransparencyState};
    methodMap_["getCurrentVoiceOverState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentVoiceOverState};
    methodMap_["setAccessibilityContentSizeMultipliers"] = MethodMetadata {.argCount = 1, .invoker = __setAccessibilityContentSizeMultipliers};
    methodMap_["setAccessibilityFocus"] = MethodMetadata {.argCount = 1, .invoker = __setAccessibilityFocus};
    methodMap_["announceForAccessibility"] = MethodMetadata {.argCount = 1, .invoker = __announceForAccessibility};
    methodMap_["announceForAccessibilityWithOptions"] = MethodMetadata {.argCount = 2, .invoker = __announceForAccessibilityWithOptions};
  }
  
private:
  static jsi::Value __getCurrentBoldTextState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentBoldTextState) == 3,
      "Expected getCurrentBoldTextState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentBoldTextState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentGrayscaleState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentGrayscaleState) == 3,
      "Expected getCurrentGrayscaleState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentGrayscaleState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentInvertColorsState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentInvertColorsState) == 3,
      "Expected getCurrentInvertColorsState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentInvertColorsState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentReduceMotionState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentReduceMotionState) == 3,
      "Expected getCurrentReduceMotionState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentReduceMotionState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentDarkerSystemColorsState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentDarkerSystemColorsState) == 3,
      "Expected getCurrentDarkerSystemColorsState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentDarkerSystemColorsState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentPrefersCrossFadeTransitionsState) == 3,
      "Expected getCurrentPrefersCrossFadeTransitionsState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentPrefersCrossFadeTransitionsState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentReduceTransparencyState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentReduceTransparencyState) == 3,
      "Expected getCurrentReduceTransparencyState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentReduceTransparencyState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getCurrentVoiceOverState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentVoiceOverState) == 3,
      "Expected getCurrentVoiceOverState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentVoiceOverState,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAccessibilityContentSizeMultipliers) == 2,
      "Expected setAccessibilityContentSizeMultipliers(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setAccessibilityContentSizeMultipliers,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setAccessibilityFocus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
      "Expected setAccessibilityFocus(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setAccessibilityFocus,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __announceForAccessibility(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::announceForAccessibility) == 2,
      "Expected announceForAccessibility(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::announceForAccessibility,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __announceForAccessibilityWithOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::announceForAccessibilityWithOptions) == 3,
      "Expected announceForAccessibilityWithOptions(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::announceForAccessibilityWithOptions,  static_cast<NativeAccessibilityManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeActionSheetManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ActionSheetManager";

protected:
  NativeActionSheetManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeActionSheetManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["showActionSheetWithOptions"] = MethodMetadata {.argCount = 2, .invoker = __showActionSheetWithOptions};
    methodMap_["showShareActionSheetWithOptions"] = MethodMetadata {.argCount = 3, .invoker = __showShareActionSheetWithOptions};
    methodMap_["dismissActionSheet"] = MethodMetadata {.argCount = 0, .invoker = __dismissActionSheet};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeActionSheetManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __showActionSheetWithOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::showActionSheetWithOptions) == 3,
      "Expected showActionSheetWithOptions(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::showActionSheetWithOptions,  static_cast<NativeActionSheetManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __showShareActionSheetWithOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::showShareActionSheetWithOptions) == 4,
      "Expected showShareActionSheetWithOptions(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::showShareActionSheetWithOptions,  static_cast<NativeActionSheetManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __dismissActionSheet(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::dismissActionSheet) == 1,
      "Expected dismissActionSheet(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::dismissActionSheet,  static_cast<NativeActionSheetManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


#pragma mark - NativeAlertManagerArgs

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct NativeAlertManagerArgs {
  P0 title;
  P1 message;
  P2 buttons;
  P3 type;
  P4 defaultValue;
  P5 cancelButtonKey;
  P6 destructiveButtonKey;
  P7 preferredButtonKey;
  P8 keyboardType;
  P9 userInterfaceStyle;
  bool operator==(const NativeAlertManagerArgs &other) const {
    return title == other.title && message == other.message && buttons == other.buttons && type == other.type && defaultValue == other.defaultValue && cancelButtonKey == other.cancelButtonKey && destructiveButtonKey == other.destructiveButtonKey && preferredButtonKey == other.preferredButtonKey && keyboardType == other.keyboardType && userInterfaceStyle == other.userInterfaceStyle;
  }
};

template <typename T>
struct NativeAlertManagerArgsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.buttons)>(rt, value.getProperty(rt, "buttons"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.defaultValue)>(rt, value.getProperty(rt, "defaultValue"), jsInvoker),
      bridging::fromJs<decltype(types.cancelButtonKey)>(rt, value.getProperty(rt, "cancelButtonKey"), jsInvoker),
      bridging::fromJs<decltype(types.destructiveButtonKey)>(rt, value.getProperty(rt, "destructiveButtonKey"), jsInvoker),
      bridging::fromJs<decltype(types.preferredButtonKey)>(rt, value.getProperty(rt, "preferredButtonKey"), jsInvoker),
      bridging::fromJs<decltype(types.keyboardType)>(rt, value.getProperty(rt, "keyboardType"), jsInvoker),
      bridging::fromJs<decltype(types.userInterfaceStyle)>(rt, value.getProperty(rt, "userInterfaceStyle"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array buttonsToJs(jsi::Runtime &rt, decltype(types.buttons) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String defaultValueToJs(jsi::Runtime &rt, decltype(types.defaultValue) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String cancelButtonKeyToJs(jsi::Runtime &rt, decltype(types.cancelButtonKey) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String destructiveButtonKeyToJs(jsi::Runtime &rt, decltype(types.destructiveButtonKey) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String preferredButtonKeyToJs(jsi::Runtime &rt, decltype(types.preferredButtonKey) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String keyboardTypeToJs(jsi::Runtime &rt, decltype(types.keyboardType) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String userInterfaceStyleToJs(jsi::Runtime &rt, decltype(types.userInterfaceStyle) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttons) {
      result.setProperty(rt, "buttons", bridging::toJs(rt, value.buttons.value(), jsInvoker));
    }
    if (value.type) {
      result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
    }
    if (value.defaultValue) {
      result.setProperty(rt, "defaultValue", bridging::toJs(rt, value.defaultValue.value(), jsInvoker));
    }
    if (value.cancelButtonKey) {
      result.setProperty(rt, "cancelButtonKey", bridging::toJs(rt, value.cancelButtonKey.value(), jsInvoker));
    }
    if (value.destructiveButtonKey) {
      result.setProperty(rt, "destructiveButtonKey", bridging::toJs(rt, value.destructiveButtonKey.value(), jsInvoker));
    }
    if (value.preferredButtonKey) {
      result.setProperty(rt, "preferredButtonKey", bridging::toJs(rt, value.preferredButtonKey.value(), jsInvoker));
    }
    if (value.keyboardType) {
      result.setProperty(rt, "keyboardType", bridging::toJs(rt, value.keyboardType.value(), jsInvoker));
    }
    if (value.userInterfaceStyle) {
      result.setProperty(rt, "userInterfaceStyle", bridging::toJs(rt, value.userInterfaceStyle.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeAlertManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "AlertManager";

protected:
  NativeAlertManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAlertManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["alertWithArgs"] = MethodMetadata {.argCount = 2, .invoker = __alertWithArgs};
  }
  
private:
  static jsi::Value __alertWithArgs(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::alertWithArgs) == 3,
      "Expected alertWithArgs(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::alertWithArgs,  static_cast<NativeAlertManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeAnimatedModuleEndResult

template <typename P0, typename P1, typename P2>
struct NativeAnimatedModuleEndResult {
  P0 finished;
  P1 value;
  P2 offset;
  bool operator==(const NativeAnimatedModuleEndResult &other) const {
    return finished == other.finished && value == other.value && offset == other.offset;
  }
};

template <typename T>
struct NativeAnimatedModuleEndResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.finished)>(rt, value.getProperty(rt, "finished"), jsInvoker),
      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker),
      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, decltype(types.finished) value) {
    return bridging::toJs(rt, value);
  }
  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
    return bridging::toJs(rt, value);
  }
  static double offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
    if (value.value) {
      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
    }
    if (value.offset) {
      result.setProperty(rt, "offset", bridging::toJs(rt, value.offset.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeAnimatedModuleEventMapping

template <typename P0, typename P1>
struct NativeAnimatedModuleEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedModuleEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename T>
struct NativeAnimatedModuleEventMappingBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.nativeEventPath)>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<decltype(types.animatedValueTag)>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, decltype(types.nativeEventPath) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, decltype(types.animatedValueTag) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeAnimatedModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeAnimatedModule";

protected:
  NativeAnimatedModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAnimatedModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["startOperationBatch"] = MethodMetadata {.argCount = 0, .invoker = __startOperationBatch};
    methodMap_["finishOperationBatch"] = MethodMetadata {.argCount = 0, .invoker = __finishOperationBatch};
    methodMap_["createAnimatedNode"] = MethodMetadata {.argCount = 2, .invoker = __createAnimatedNode};
    methodMap_["updateAnimatedNodeConfig"] = MethodMetadata {.argCount = 2, .invoker = __updateAnimatedNodeConfig};
    methodMap_["getValue"] = MethodMetadata {.argCount = 2, .invoker = __getValue};
    methodMap_["startListeningToAnimatedNodeValue"] = MethodMetadata {.argCount = 1, .invoker = __startListeningToAnimatedNodeValue};
    methodMap_["stopListeningToAnimatedNodeValue"] = MethodMetadata {.argCount = 1, .invoker = __stopListeningToAnimatedNodeValue};
    methodMap_["connectAnimatedNodes"] = MethodMetadata {.argCount = 2, .invoker = __connectAnimatedNodes};
    methodMap_["disconnectAnimatedNodes"] = MethodMetadata {.argCount = 2, .invoker = __disconnectAnimatedNodes};
    methodMap_["startAnimatingNode"] = MethodMetadata {.argCount = 4, .invoker = __startAnimatingNode};
    methodMap_["stopAnimation"] = MethodMetadata {.argCount = 1, .invoker = __stopAnimation};
    methodMap_["setAnimatedNodeValue"] = MethodMetadata {.argCount = 2, .invoker = __setAnimatedNodeValue};
    methodMap_["setAnimatedNodeOffset"] = MethodMetadata {.argCount = 2, .invoker = __setAnimatedNodeOffset};
    methodMap_["flattenAnimatedNodeOffset"] = MethodMetadata {.argCount = 1, .invoker = __flattenAnimatedNodeOffset};
    methodMap_["extractAnimatedNodeOffset"] = MethodMetadata {.argCount = 1, .invoker = __extractAnimatedNodeOffset};
    methodMap_["connectAnimatedNodeToView"] = MethodMetadata {.argCount = 2, .invoker = __connectAnimatedNodeToView};
    methodMap_["disconnectAnimatedNodeFromView"] = MethodMetadata {.argCount = 2, .invoker = __disconnectAnimatedNodeFromView};
    methodMap_["restoreDefaultValues"] = MethodMetadata {.argCount = 1, .invoker = __restoreDefaultValues};
    methodMap_["dropAnimatedNode"] = MethodMetadata {.argCount = 1, .invoker = __dropAnimatedNode};
    methodMap_["addAnimatedEventToView"] = MethodMetadata {.argCount = 3, .invoker = __addAnimatedEventToView};
    methodMap_["removeAnimatedEventFromView"] = MethodMetadata {.argCount = 3, .invoker = __removeAnimatedEventFromView};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
    methodMap_["queueAndExecuteBatchedOperations"] = MethodMetadata {.argCount = 1, .invoker = __queueAndExecuteBatchedOperations};
  }
  
private:
  static jsi::Value __startOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::startOperationBatch) == 1,
      "Expected startOperationBatch(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::startOperationBatch,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __finishOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::finishOperationBatch) == 1,
      "Expected finishOperationBatch(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::finishOperationBatch,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __createAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createAnimatedNode) == 3,
      "Expected createAnimatedNode(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::createAnimatedNode,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __updateAnimatedNodeConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
      "Expected updateAnimatedNodeConfig(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::updateAnimatedNodeConfig,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 3,
      "Expected getValue(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getValue,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __startListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
      "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::startListeningToAnimatedNodeValue,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __stopListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
      "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::stopListeningToAnimatedNodeValue,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __connectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
      "Expected connectAnimatedNodes(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::connectAnimatedNodes,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __disconnectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
      "Expected disconnectAnimatedNodes(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::disconnectAnimatedNodes,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __startAnimatingNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::startAnimatingNode) == 5,
      "Expected startAnimatingNode(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::startAnimatingNode,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __stopAnimation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::stopAnimation) == 2,
      "Expected stopAnimation(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::stopAnimation,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
      "Expected setAnimatedNodeValue(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setAnimatedNodeValue,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
      "Expected setAnimatedNodeOffset(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setAnimatedNodeOffset,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __flattenAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
      "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::flattenAnimatedNodeOffset,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __extractAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
      "Expected extractAnimatedNodeOffset(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::extractAnimatedNodeOffset,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __connectAnimatedNodeToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
      "Expected connectAnimatedNodeToView(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::connectAnimatedNodeToView,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __disconnectAnimatedNodeFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
      "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::disconnectAnimatedNodeFromView,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __restoreDefaultValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::restoreDefaultValues) == 2,
      "Expected restoreDefaultValues(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::restoreDefaultValues,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __dropAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::dropAnimatedNode) == 2,
      "Expected dropAnimatedNode(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::dropAnimatedNode,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __addAnimatedEventToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
      "Expected addAnimatedEventToView(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::addAnimatedEventToView,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeAnimatedEventFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
      "Expected removeAnimatedEventFromView(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::removeAnimatedEventFromView,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __queueAndExecuteBatchedOperations(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
      "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::queueAndExecuteBatchedOperations,  static_cast<NativeAnimatedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeAnimatedTurboModuleEndResult

template <typename P0, typename P1, typename P2>
struct NativeAnimatedTurboModuleEndResult {
  P0 finished;
  P1 value;
  P2 offset;
  bool operator==(const NativeAnimatedTurboModuleEndResult &other) const {
    return finished == other.finished && value == other.value && offset == other.offset;
  }
};

template <typename T>
struct NativeAnimatedTurboModuleEndResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.finished)>(rt, value.getProperty(rt, "finished"), jsInvoker),
      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker),
      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, decltype(types.finished) value) {
    return bridging::toJs(rt, value);
  }
  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
    return bridging::toJs(rt, value);
  }
  static double offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
    if (value.value) {
      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
    }
    if (value.offset) {
      result.setProperty(rt, "offset", bridging::toJs(rt, value.offset.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeAnimatedTurboModuleEventMapping

template <typename P0, typename P1>
struct NativeAnimatedTurboModuleEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedTurboModuleEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename T>
struct NativeAnimatedTurboModuleEventMappingBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.nativeEventPath)>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<decltype(types.animatedValueTag)>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, decltype(types.nativeEventPath) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, decltype(types.animatedValueTag) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeAnimatedTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeAnimatedTurboModule";

protected:
  NativeAnimatedTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAnimatedTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["startOperationBatch"] = MethodMetadata {.argCount = 0, .invoker = __startOperationBatch};
    methodMap_["finishOperationBatch"] = MethodMetadata {.argCount = 0, .invoker = __finishOperationBatch};
    methodMap_["createAnimatedNode"] = MethodMetadata {.argCount = 2, .invoker = __createAnimatedNode};
    methodMap_["updateAnimatedNodeConfig"] = MethodMetadata {.argCount = 2, .invoker = __updateAnimatedNodeConfig};
    methodMap_["getValue"] = MethodMetadata {.argCount = 2, .invoker = __getValue};
    methodMap_["startListeningToAnimatedNodeValue"] = MethodMetadata {.argCount = 1, .invoker = __startListeningToAnimatedNodeValue};
    methodMap_["stopListeningToAnimatedNodeValue"] = MethodMetadata {.argCount = 1, .invoker = __stopListeningToAnimatedNodeValue};
    methodMap_["connectAnimatedNodes"] = MethodMetadata {.argCount = 2, .invoker = __connectAnimatedNodes};
    methodMap_["disconnectAnimatedNodes"] = MethodMetadata {.argCount = 2, .invoker = __disconnectAnimatedNodes};
    methodMap_["startAnimatingNode"] = MethodMetadata {.argCount = 4, .invoker = __startAnimatingNode};
    methodMap_["stopAnimation"] = MethodMetadata {.argCount = 1, .invoker = __stopAnimation};
    methodMap_["setAnimatedNodeValue"] = MethodMetadata {.argCount = 2, .invoker = __setAnimatedNodeValue};
    methodMap_["setAnimatedNodeOffset"] = MethodMetadata {.argCount = 2, .invoker = __setAnimatedNodeOffset};
    methodMap_["flattenAnimatedNodeOffset"] = MethodMetadata {.argCount = 1, .invoker = __flattenAnimatedNodeOffset};
    methodMap_["extractAnimatedNodeOffset"] = MethodMetadata {.argCount = 1, .invoker = __extractAnimatedNodeOffset};
    methodMap_["connectAnimatedNodeToView"] = MethodMetadata {.argCount = 2, .invoker = __connectAnimatedNodeToView};
    methodMap_["disconnectAnimatedNodeFromView"] = MethodMetadata {.argCount = 2, .invoker = __disconnectAnimatedNodeFromView};
    methodMap_["restoreDefaultValues"] = MethodMetadata {.argCount = 1, .invoker = __restoreDefaultValues};
    methodMap_["dropAnimatedNode"] = MethodMetadata {.argCount = 1, .invoker = __dropAnimatedNode};
    methodMap_["addAnimatedEventToView"] = MethodMetadata {.argCount = 3, .invoker = __addAnimatedEventToView};
    methodMap_["removeAnimatedEventFromView"] = MethodMetadata {.argCount = 3, .invoker = __removeAnimatedEventFromView};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
    methodMap_["queueAndExecuteBatchedOperations"] = MethodMetadata {.argCount = 1, .invoker = __queueAndExecuteBatchedOperations};
  }
  
private:
  static jsi::Value __startOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::startOperationBatch) == 1,
      "Expected startOperationBatch(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::startOperationBatch,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __finishOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::finishOperationBatch) == 1,
      "Expected finishOperationBatch(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::finishOperationBatch,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __createAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createAnimatedNode) == 3,
      "Expected createAnimatedNode(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::createAnimatedNode,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __updateAnimatedNodeConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
      "Expected updateAnimatedNodeConfig(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::updateAnimatedNodeConfig,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 3,
      "Expected getValue(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getValue,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __startListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
      "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::startListeningToAnimatedNodeValue,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __stopListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
      "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::stopListeningToAnimatedNodeValue,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __connectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
      "Expected connectAnimatedNodes(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::connectAnimatedNodes,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __disconnectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
      "Expected disconnectAnimatedNodes(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::disconnectAnimatedNodes,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __startAnimatingNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::startAnimatingNode) == 5,
      "Expected startAnimatingNode(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::startAnimatingNode,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __stopAnimation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::stopAnimation) == 2,
      "Expected stopAnimation(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::stopAnimation,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
      "Expected setAnimatedNodeValue(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setAnimatedNodeValue,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
      "Expected setAnimatedNodeOffset(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setAnimatedNodeOffset,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __flattenAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
      "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::flattenAnimatedNodeOffset,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __extractAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
      "Expected extractAnimatedNodeOffset(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::extractAnimatedNodeOffset,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __connectAnimatedNodeToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
      "Expected connectAnimatedNodeToView(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::connectAnimatedNodeToView,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __disconnectAnimatedNodeFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
      "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::disconnectAnimatedNodeFromView,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __restoreDefaultValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::restoreDefaultValues) == 2,
      "Expected restoreDefaultValues(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::restoreDefaultValues,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __dropAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::dropAnimatedNode) == 2,
      "Expected dropAnimatedNode(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::dropAnimatedNode,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __addAnimatedEventToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
      "Expected addAnimatedEventToView(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::addAnimatedEventToView,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeAnimatedEventFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
      "Expected removeAnimatedEventFromView(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::removeAnimatedEventFromView,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __queueAndExecuteBatchedOperations(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
      "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::queueAndExecuteBatchedOperations,  static_cast<NativeAnimatedTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeAppearanceCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Appearance";

protected:
  NativeAppearanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAppearanceCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getColorScheme"] = MethodMetadata {.argCount = 0, .invoker = __getColorScheme};
    methodMap_["setColorScheme"] = MethodMetadata {.argCount = 1, .invoker = __setColorScheme};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __getColorScheme(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getColorScheme) == 1,
      "Expected getColorScheme(...) to have 1 parameters");
    auto result = bridging::callFromJs<std::optional<jsi::String>>(rt, &T::getColorScheme,  static_cast<NativeAppearanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __setColorScheme(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setColorScheme) == 2,
      "Expected setColorScheme(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setColorScheme,  static_cast<NativeAppearanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeAppearanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeAppearanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


#pragma mark - NativeAppStateAppState

template <typename P0>
struct NativeAppStateAppState {
  P0 app_state;
  bool operator==(const NativeAppStateAppState &other) const {
    return app_state == other.app_state;
  }
};

template <typename T>
struct NativeAppStateAppStateBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.app_state)>(rt, value.getProperty(rt, "app_state"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String app_stateToJs(jsi::Runtime &rt, decltype(types.app_state) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "app_state", bridging::toJs(rt, value.app_state, jsInvoker));
    return result;
  }
};



#pragma mark - NativeAppStateAppStateConstants

template <typename P0>
struct NativeAppStateAppStateConstants {
  P0 initialAppState;
  bool operator==(const NativeAppStateAppStateConstants &other) const {
    return initialAppState == other.initialAppState;
  }
};

template <typename T>
struct NativeAppStateAppStateConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.initialAppState)>(rt, value.getProperty(rt, "initialAppState"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String initialAppStateToJs(jsi::Runtime &rt, decltype(types.initialAppState) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "initialAppState", bridging::toJs(rt, value.initialAppState, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeAppStateCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "AppState";

protected:
  NativeAppStateCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAppStateCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getCurrentAppState"] = MethodMetadata {.argCount = 2, .invoker = __getCurrentAppState};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeAppStateCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getCurrentAppState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getCurrentAppState) == 3,
      "Expected getCurrentAppState(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::getCurrentAppState,  static_cast<NativeAppStateCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeAppStateCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeAppStateCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


#pragma mark - NativeBlobModuleConstants

template <typename P0, typename P1>
struct NativeBlobModuleConstants {
  P0 BLOB_URI_SCHEME;
  P1 BLOB_URI_HOST;
  bool operator==(const NativeBlobModuleConstants &other) const {
    return BLOB_URI_SCHEME == other.BLOB_URI_SCHEME && BLOB_URI_HOST == other.BLOB_URI_HOST;
  }
};

template <typename T>
struct NativeBlobModuleConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.BLOB_URI_SCHEME)>(rt, value.getProperty(rt, "BLOB_URI_SCHEME"), jsInvoker),
      bridging::fromJs<decltype(types.BLOB_URI_HOST)>(rt, value.getProperty(rt, "BLOB_URI_HOST"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> BLOB_URI_SCHEMEToJs(jsi::Runtime &rt, decltype(types.BLOB_URI_SCHEME) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> BLOB_URI_HOSTToJs(jsi::Runtime &rt, decltype(types.BLOB_URI_HOST) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "BLOB_URI_SCHEME", bridging::toJs(rt, value.BLOB_URI_SCHEME, jsInvoker));
    result.setProperty(rt, "BLOB_URI_HOST", bridging::toJs(rt, value.BLOB_URI_HOST, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeBlobModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "BlobModule";

protected:
  NativeBlobModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeBlobModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["addNetworkingHandler"] = MethodMetadata {.argCount = 0, .invoker = __addNetworkingHandler};
    methodMap_["addWebSocketHandler"] = MethodMetadata {.argCount = 1, .invoker = __addWebSocketHandler};
    methodMap_["removeWebSocketHandler"] = MethodMetadata {.argCount = 1, .invoker = __removeWebSocketHandler};
    methodMap_["sendOverSocket"] = MethodMetadata {.argCount = 2, .invoker = __sendOverSocket};
    methodMap_["createFromParts"] = MethodMetadata {.argCount = 2, .invoker = __createFromParts};
    methodMap_["release"] = MethodMetadata {.argCount = 1, .invoker = __release};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __addNetworkingHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::addNetworkingHandler) == 1,
      "Expected addNetworkingHandler(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::addNetworkingHandler,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __addWebSocketHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addWebSocketHandler) == 2,
      "Expected addWebSocketHandler(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addWebSocketHandler,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __removeWebSocketHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeWebSocketHandler) == 2,
      "Expected removeWebSocketHandler(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeWebSocketHandler,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __sendOverSocket(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::sendOverSocket) == 3,
      "Expected sendOverSocket(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::sendOverSocket,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __createFromParts(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createFromParts) == 3,
      "Expected createFromParts(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::createFromParts,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __release(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::release) == 2,
      "Expected release(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::release,  static_cast<NativeBlobModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeClipboardCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Clipboard";

protected:
  NativeClipboardCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeClipboardCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getString"] = MethodMetadata {.argCount = 0, .invoker = __getString};
    methodMap_["setString"] = MethodMetadata {.argCount = 1, .invoker = __setString};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeClipboardCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 1,
      "Expected getString(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getString,  static_cast<NativeClipboardCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __setString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setString) == 2,
      "Expected setString(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setString,  static_cast<NativeClipboardCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeDeviceEventManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "DeviceEventManager";

protected:
  NativeDeviceEventManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDeviceEventManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["invokeDefaultBackPressHandler"] = MethodMetadata {.argCount = 0, .invoker = __invokeDefaultBackPressHandler};
  }
  
private:
  static jsi::Value __invokeDefaultBackPressHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::invokeDefaultBackPressHandler) == 1,
      "Expected invokeDefaultBackPressHandler(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::invokeDefaultBackPressHandler,  static_cast<NativeDeviceEventManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


#pragma mark - NativeDeviceInfoDeviceInfoConstants

template <typename P0, typename P1, typename P2>
struct NativeDeviceInfoDeviceInfoConstants {
  P0 Dimensions;
  P1 isEdgeToEdge;
  P2 isIPhoneX_deprecated;
  bool operator==(const NativeDeviceInfoDeviceInfoConstants &other) const {
    return Dimensions == other.Dimensions && isEdgeToEdge == other.isEdgeToEdge && isIPhoneX_deprecated == other.isIPhoneX_deprecated;
  }
};

template <typename T>
struct NativeDeviceInfoDeviceInfoConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.Dimensions)>(rt, value.getProperty(rt, "Dimensions"), jsInvoker),
      bridging::fromJs<decltype(types.isEdgeToEdge)>(rt, value.getProperty(rt, "isEdgeToEdge"), jsInvoker),
      bridging::fromJs<decltype(types.isIPhoneX_deprecated)>(rt, value.getProperty(rt, "isIPhoneX_deprecated"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object DimensionsToJs(jsi::Runtime &rt, decltype(types.Dimensions) value) {
    return bridging::toJs(rt, value);
  }
  static bool isEdgeToEdgeToJs(jsi::Runtime &rt, decltype(types.isEdgeToEdge) value) {
    return bridging::toJs(rt, value);
  }
  static bool isIPhoneX_deprecatedToJs(jsi::Runtime &rt, decltype(types.isIPhoneX_deprecated) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "Dimensions", bridging::toJs(rt, value.Dimensions, jsInvoker));
    if (value.isEdgeToEdge) {
      result.setProperty(rt, "isEdgeToEdge", bridging::toJs(rt, value.isEdgeToEdge.value(), jsInvoker));
    }
    if (value.isIPhoneX_deprecated) {
      result.setProperty(rt, "isIPhoneX_deprecated", bridging::toJs(rt, value.isIPhoneX_deprecated.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeDeviceInfoDimensionsPayload

template <typename P0, typename P1, typename P2, typename P3>
struct NativeDeviceInfoDimensionsPayload {
  P0 window;
  P1 screen;
  P2 windowPhysicalPixels;
  P3 screenPhysicalPixels;
  bool operator==(const NativeDeviceInfoDimensionsPayload &other) const {
    return window == other.window && screen == other.screen && windowPhysicalPixels == other.windowPhysicalPixels && screenPhysicalPixels == other.screenPhysicalPixels;
  }
};

template <typename T>
struct NativeDeviceInfoDimensionsPayloadBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.window)>(rt, value.getProperty(rt, "window"), jsInvoker),
      bridging::fromJs<decltype(types.screen)>(rt, value.getProperty(rt, "screen"), jsInvoker),
      bridging::fromJs<decltype(types.windowPhysicalPixels)>(rt, value.getProperty(rt, "windowPhysicalPixels"), jsInvoker),
      bridging::fromJs<decltype(types.screenPhysicalPixels)>(rt, value.getProperty(rt, "screenPhysicalPixels"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object windowToJs(jsi::Runtime &rt, decltype(types.window) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object screenToJs(jsi::Runtime &rt, decltype(types.screen) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object windowPhysicalPixelsToJs(jsi::Runtime &rt, decltype(types.windowPhysicalPixels) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object screenPhysicalPixelsToJs(jsi::Runtime &rt, decltype(types.screenPhysicalPixels) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.window) {
      result.setProperty(rt, "window", bridging::toJs(rt, value.window.value(), jsInvoker));
    }
    if (value.screen) {
      result.setProperty(rt, "screen", bridging::toJs(rt, value.screen.value(), jsInvoker));
    }
    if (value.windowPhysicalPixels) {
      result.setProperty(rt, "windowPhysicalPixels", bridging::toJs(rt, value.windowPhysicalPixels.value(), jsInvoker));
    }
    if (value.screenPhysicalPixels) {
      result.setProperty(rt, "screenPhysicalPixels", bridging::toJs(rt, value.screenPhysicalPixels.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeDeviceInfoDisplayMetrics

template <typename P0, typename P1, typename P2, typename P3>
struct NativeDeviceInfoDisplayMetrics {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  bool operator==(const NativeDeviceInfoDisplayMetrics &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale;
  }
};

template <typename T>
struct NativeDeviceInfoDisplayMetricsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<decltype(types.fontScale)>(rt, value.getProperty(rt, "fontScale"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }
  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }
  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
    return bridging::toJs(rt, value);
  }
  static double fontScaleToJs(jsi::Runtime &rt, decltype(types.fontScale) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    return result;
  }
};



#pragma mark - NativeDeviceInfoDisplayMetricsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeDeviceInfoDisplayMetricsAndroid {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  P4 densityDpi;
  bool operator==(const NativeDeviceInfoDisplayMetricsAndroid &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale && densityDpi == other.densityDpi;
  }
};

template <typename T>
struct NativeDeviceInfoDisplayMetricsAndroidBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<decltype(types.fontScale)>(rt, value.getProperty(rt, "fontScale"), jsInvoker),
      bridging::fromJs<decltype(types.densityDpi)>(rt, value.getProperty(rt, "densityDpi"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }
  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }
  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
    return bridging::toJs(rt, value);
  }
  static double fontScaleToJs(jsi::Runtime &rt, decltype(types.fontScale) value) {
    return bridging::toJs(rt, value);
  }
  static double densityDpiToJs(jsi::Runtime &rt, decltype(types.densityDpi) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    result.setProperty(rt, "densityDpi", bridging::toJs(rt, value.densityDpi, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeDeviceInfoCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "DeviceInfo";

protected:
  NativeDeviceInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDeviceInfoCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeDeviceInfoCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeDevLoadingViewCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "DevLoadingView";

protected:
  NativeDevLoadingViewCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDevLoadingViewCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["showMessage"] = MethodMetadata {.argCount = 3, .invoker = __showMessage};
    methodMap_["hide"] = MethodMetadata {.argCount = 0, .invoker = __hide};
  }
  
private:
  static jsi::Value __showMessage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::showMessage) == 4,
      "Expected showMessage(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::showMessage,  static_cast<NativeDevLoadingViewCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asNumber()),
      count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asNumber()));return jsi::Value::undefined();
  }

  static jsi::Value __hide(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::hide) == 1,
      "Expected hide(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::hide,  static_cast<NativeDevLoadingViewCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeDevSettingsCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "DevSettings";

protected:
  NativeDevSettingsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDevSettingsCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["reload"] = MethodMetadata {.argCount = 0, .invoker = __reload};
    methodMap_["reloadWithReason"] = MethodMetadata {.argCount = 1, .invoker = __reloadWithReason};
    methodMap_["onFastRefresh"] = MethodMetadata {.argCount = 0, .invoker = __onFastRefresh};
    methodMap_["setHotLoadingEnabled"] = MethodMetadata {.argCount = 1, .invoker = __setHotLoadingEnabled};
    methodMap_["setProfilingEnabled"] = MethodMetadata {.argCount = 1, .invoker = __setProfilingEnabled};
    methodMap_["toggleElementInspector"] = MethodMetadata {.argCount = 0, .invoker = __toggleElementInspector};
    methodMap_["addMenuItem"] = MethodMetadata {.argCount = 1, .invoker = __addMenuItem};
    methodMap_["openDebugger"] = MethodMetadata {.argCount = 0, .invoker = __openDebugger};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
    methodMap_["setIsShakeToShowDevMenuEnabled"] = MethodMetadata {.argCount = 1, .invoker = __setIsShakeToShowDevMenuEnabled};
  }
  
private:
  static jsi::Value __reload(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::reload) == 1,
      "Expected reload(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::reload,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __reloadWithReason(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reloadWithReason) == 2,
      "Expected reloadWithReason(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::reloadWithReason,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __onFastRefresh(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::onFastRefresh) == 1,
      "Expected onFastRefresh(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::onFastRefresh,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __setHotLoadingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
      "Expected setHotLoadingEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setHotLoadingEnabled,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __setProfilingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setProfilingEnabled) == 2,
      "Expected setProfilingEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setProfilingEnabled,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __toggleElementInspector(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::toggleElementInspector) == 1,
      "Expected toggleElementInspector(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::toggleElementInspector,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __addMenuItem(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addMenuItem) == 2,
      "Expected addMenuItem(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addMenuItem,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __openDebugger(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::openDebugger) == 1,
      "Expected openDebugger(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::openDebugger,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setIsShakeToShowDevMenuEnabled) == 2,
      "Expected setIsShakeToShowDevMenuEnabled(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setIsShakeToShowDevMenuEnabled,  static_cast<NativeDevSettingsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }
};


#pragma mark - NativeDialogManagerAndroidDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativeDialogManagerAndroidDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  bool operator==(const NativeDialogManagerAndroidDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable;
  }
};

template <typename T>
struct NativeDialogManagerAndroidDialogOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.buttonPositive)>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<decltype(types.buttonNegative)>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<decltype(types.buttonNeutral)>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<decltype(types.items)>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<decltype(types.cancelable)>(rt, value.getProperty(rt, "cancelable"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, decltype(types.buttonPositive) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, decltype(types.buttonNegative) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, decltype(types.buttonNeutral) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array itemsToJs(jsi::Runtime &rt, decltype(types.items) value) {
    return bridging::toJs(rt, value);
  }
  static bool cancelableToJs(jsi::Runtime &rt, decltype(types.cancelable) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttonPositive) {
      result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
    }
    if (value.buttonNegative) {
      result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
    }
    if (value.buttonNeutral) {
      result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
    }
    if (value.items) {
      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
    }
    if (value.cancelable) {
      result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeDialogManagerAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "DialogManagerAndroid";

protected:
  NativeDialogManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDialogManagerAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["showAlert"] = MethodMetadata {.argCount = 3, .invoker = __showAlert};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeDialogManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __showAlert(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::showAlert) == 4,
      "Expected showAlert(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::showAlert,  static_cast<NativeDialogManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeExceptionsManagerExceptionData

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct NativeExceptionsManagerExceptionData {
  P0 message;
  P1 originalMessage;
  P2 name;
  P3 componentStack;
  P4 stack;
  P5 id;
  P6 isFatal;
  P7 extraData;
  bool operator==(const NativeExceptionsManagerExceptionData &other) const {
    return message == other.message && originalMessage == other.originalMessage && name == other.name && componentStack == other.componentStack && stack == other.stack && id == other.id && isFatal == other.isFatal && extraData == other.extraData;
  }
};

template <typename T>
struct NativeExceptionsManagerExceptionDataBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.originalMessage)>(rt, value.getProperty(rt, "originalMessage"), jsInvoker),
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.componentStack)>(rt, value.getProperty(rt, "componentStack"), jsInvoker),
      bridging::fromJs<decltype(types.stack)>(rt, value.getProperty(rt, "stack"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.isFatal)>(rt, value.getProperty(rt, "isFatal"), jsInvoker),
      bridging::fromJs<decltype(types.extraData)>(rt, value.getProperty(rt, "extraData"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> originalMessageToJs(jsi::Runtime &rt, decltype(types.originalMessage) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> componentStackToJs(jsi::Runtime &rt, decltype(types.componentStack) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array stackToJs(jsi::Runtime &rt, decltype(types.stack) value) {
    return bridging::toJs(rt, value);
  }
  static double idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }
  static bool isFatalToJs(jsi::Runtime &rt, decltype(types.isFatal) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object extraDataToJs(jsi::Runtime &rt, decltype(types.extraData) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "message", bridging::toJs(rt, value.message, jsInvoker));
    result.setProperty(rt, "originalMessage", bridging::toJs(rt, value.originalMessage, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "componentStack", bridging::toJs(rt, value.componentStack, jsInvoker));
    result.setProperty(rt, "stack", bridging::toJs(rt, value.stack, jsInvoker));
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "isFatal", bridging::toJs(rt, value.isFatal, jsInvoker));
    if (value.extraData) {
      result.setProperty(rt, "extraData", bridging::toJs(rt, value.extraData.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeExceptionsManagerStackFrame

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeExceptionsManagerStackFrame {
  P0 column;
  P1 file;
  P2 lineNumber;
  P3 methodName;
  P4 collapse;
  bool operator==(const NativeExceptionsManagerStackFrame &other) const {
    return column == other.column && file == other.file && lineNumber == other.lineNumber && methodName == other.methodName && collapse == other.collapse;
  }
};

template <typename T>
struct NativeExceptionsManagerStackFrameBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.column)>(rt, value.getProperty(rt, "column"), jsInvoker),
      bridging::fromJs<decltype(types.file)>(rt, value.getProperty(rt, "file"), jsInvoker),
      bridging::fromJs<decltype(types.lineNumber)>(rt, value.getProperty(rt, "lineNumber"), jsInvoker),
      bridging::fromJs<decltype(types.methodName)>(rt, value.getProperty(rt, "methodName"), jsInvoker),
      bridging::fromJs<decltype(types.collapse)>(rt, value.getProperty(rt, "collapse"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<double> columnToJs(jsi::Runtime &rt, decltype(types.column) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> fileToJs(jsi::Runtime &rt, decltype(types.file) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> lineNumberToJs(jsi::Runtime &rt, decltype(types.lineNumber) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String methodNameToJs(jsi::Runtime &rt, decltype(types.methodName) value) {
    return bridging::toJs(rt, value);
  }
  static bool collapseToJs(jsi::Runtime &rt, decltype(types.collapse) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "column", bridging::toJs(rt, value.column, jsInvoker));
    result.setProperty(rt, "file", bridging::toJs(rt, value.file, jsInvoker));
    result.setProperty(rt, "lineNumber", bridging::toJs(rt, value.lineNumber, jsInvoker));
    result.setProperty(rt, "methodName", bridging::toJs(rt, value.methodName, jsInvoker));
    if (value.collapse) {
      result.setProperty(rt, "collapse", bridging::toJs(rt, value.collapse.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeExceptionsManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ExceptionsManager";

protected:
  NativeExceptionsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeExceptionsManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["reportFatalException"] = MethodMetadata {.argCount = 3, .invoker = __reportFatalException};
    methodMap_["reportSoftException"] = MethodMetadata {.argCount = 3, .invoker = __reportSoftException};
    methodMap_["reportException"] = MethodMetadata {.argCount = 1, .invoker = __reportException};
    methodMap_["dismissRedbox"] = MethodMetadata {.argCount = 0, .invoker = __dismissRedbox};
  }
  
private:
  static jsi::Value __reportFatalException(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reportFatalException) == 4,
      "Expected reportFatalException(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::reportFatalException,  static_cast<NativeExceptionsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __reportSoftException(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reportSoftException) == 4,
      "Expected reportSoftException(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::reportSoftException,  static_cast<NativeExceptionsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __reportException(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reportException) == 2,
      "Expected reportException(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::reportException,  static_cast<NativeExceptionsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __dismissRedbox(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::dismissRedbox) == 1,
      "Expected dismissRedbox(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::dismissRedbox,  static_cast<NativeExceptionsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeFileReaderModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "FileReaderModule";

protected:
  NativeFileReaderModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeFileReaderModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["readAsDataURL"] = MethodMetadata {.argCount = 1, .invoker = __readAsDataURL};
    methodMap_["readAsText"] = MethodMetadata {.argCount = 2, .invoker = __readAsText};
  }
  
private:
  static jsi::Value __readAsDataURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::readAsDataURL) == 2,
      "Expected readAsDataURL(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::readAsDataURL,  static_cast<NativeFileReaderModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));
  }

  static jsi::Value __readAsText(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::readAsText) == 3,
      "Expected readAsText(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::readAsText,  static_cast<NativeFileReaderModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeFrameRateLoggerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "FrameRateLogger";

protected:
  NativeFrameRateLoggerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeFrameRateLoggerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["setGlobalOptions"] = MethodMetadata {.argCount = 1, .invoker = __setGlobalOptions};
    methodMap_["setContext"] = MethodMetadata {.argCount = 1, .invoker = __setContext};
    methodMap_["beginScroll"] = MethodMetadata {.argCount = 0, .invoker = __beginScroll};
    methodMap_["endScroll"] = MethodMetadata {.argCount = 0, .invoker = __endScroll};
  }
  
private:
  static jsi::Value __setGlobalOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setGlobalOptions) == 2,
      "Expected setGlobalOptions(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setGlobalOptions,  static_cast<NativeFrameRateLoggerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setContext(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setContext) == 2,
      "Expected setContext(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setContext,  static_cast<NativeFrameRateLoggerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __beginScroll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::beginScroll) == 1,
      "Expected beginScroll(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::beginScroll,  static_cast<NativeFrameRateLoggerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __endScroll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::endScroll) == 1,
      "Expected endScroll(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::endScroll,  static_cast<NativeFrameRateLoggerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "HeadlessJsTaskSupport";

protected:
  NativeHeadlessJsTaskSupportCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeHeadlessJsTaskSupportCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["notifyTaskFinished"] = MethodMetadata {.argCount = 1, .invoker = __notifyTaskFinished};
    methodMap_["notifyTaskRetry"] = MethodMetadata {.argCount = 1, .invoker = __notifyTaskRetry};
  }
  
private:
  static jsi::Value __notifyTaskFinished(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::notifyTaskFinished) == 2,
      "Expected notifyTaskFinished(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::notifyTaskFinished,  static_cast<NativeHeadlessJsTaskSupportCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __notifyTaskRetry(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::notifyTaskRetry) == 2,
      "Expected notifyTaskRetry(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::notifyTaskRetry,  static_cast<NativeHeadlessJsTaskSupportCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());
  }
};


#pragma mark - NativeI18nManagerI18nManagerConstants

template <typename P0, typename P1, typename P2>
struct NativeI18nManagerI18nManagerConstants {
  P0 doLeftAndRightSwapInRTL;
  P1 isRTL;
  P2 localeIdentifier;
  bool operator==(const NativeI18nManagerI18nManagerConstants &other) const {
    return doLeftAndRightSwapInRTL == other.doLeftAndRightSwapInRTL && isRTL == other.isRTL && localeIdentifier == other.localeIdentifier;
  }
};

template <typename T>
struct NativeI18nManagerI18nManagerConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.doLeftAndRightSwapInRTL)>(rt, value.getProperty(rt, "doLeftAndRightSwapInRTL"), jsInvoker),
      bridging::fromJs<decltype(types.isRTL)>(rt, value.getProperty(rt, "isRTL"), jsInvoker),
      bridging::fromJs<decltype(types.localeIdentifier)>(rt, value.getProperty(rt, "localeIdentifier"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool doLeftAndRightSwapInRTLToJs(jsi::Runtime &rt, decltype(types.doLeftAndRightSwapInRTL) value) {
    return bridging::toJs(rt, value);
  }
  static bool isRTLToJs(jsi::Runtime &rt, decltype(types.isRTL) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> localeIdentifierToJs(jsi::Runtime &rt, decltype(types.localeIdentifier) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "doLeftAndRightSwapInRTL", bridging::toJs(rt, value.doLeftAndRightSwapInRTL, jsInvoker));
    result.setProperty(rt, "isRTL", bridging::toJs(rt, value.isRTL, jsInvoker));
    if (value.localeIdentifier) {
      result.setProperty(rt, "localeIdentifier", bridging::toJs(rt, value.localeIdentifier.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeI18nManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "I18nManager";

protected:
  NativeI18nManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeI18nManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["allowRTL"] = MethodMetadata {.argCount = 1, .invoker = __allowRTL};
    methodMap_["forceRTL"] = MethodMetadata {.argCount = 1, .invoker = __forceRTL};
    methodMap_["swapLeftAndRightInRTL"] = MethodMetadata {.argCount = 1, .invoker = __swapLeftAndRightInRTL};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeI18nManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __allowRTL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::allowRTL) == 2,
      "Expected allowRTL(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::allowRTL,  static_cast<NativeI18nManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __forceRTL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::forceRTL) == 2,
      "Expected forceRTL(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::forceRTL,  static_cast<NativeI18nManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __swapLeftAndRightInRTL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::swapLeftAndRightInRTL) == 2,
      "Expected swapLeftAndRightInRTL(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::swapLeftAndRightInRTL,  static_cast<NativeI18nManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }
};


#pragma mark - NativeImageEditorOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeImageEditorOptions {
  P0 offset;
  P1 size;
  P2 displaySize;
  P3 resizeMode;
  P4 allowExternalStorage;
  bool operator==(const NativeImageEditorOptions &other) const {
    return offset == other.offset && size == other.size && displaySize == other.displaySize && resizeMode == other.resizeMode && allowExternalStorage == other.allowExternalStorage;
  }
};

template <typename T>
struct NativeImageEditorOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.displaySize)>(rt, value.getProperty(rt, "displaySize"), jsInvoker),
      bridging::fromJs<decltype(types.resizeMode)>(rt, value.getProperty(rt, "resizeMode"), jsInvoker),
      bridging::fromJs<decltype(types.allowExternalStorage)>(rt, value.getProperty(rt, "allowExternalStorage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Object> displaySizeToJs(jsi::Runtime &rt, decltype(types.displaySize) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> resizeModeToJs(jsi::Runtime &rt, decltype(types.resizeMode) value) {
    return bridging::toJs(rt, value);
  }
  static bool allowExternalStorageToJs(jsi::Runtime &rt, decltype(types.allowExternalStorage) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "offset", bridging::toJs(rt, value.offset, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.displaySize) {
      result.setProperty(rt, "displaySize", bridging::toJs(rt, value.displaySize.value(), jsInvoker));
    }
    if (value.resizeMode) {
      result.setProperty(rt, "resizeMode", bridging::toJs(rt, value.resizeMode.value(), jsInvoker));
    }
    if (value.allowExternalStorage) {
      result.setProperty(rt, "allowExternalStorage", bridging::toJs(rt, value.allowExternalStorage.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeImageEditorCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ImageEditingManager";

protected:
  NativeImageEditorCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeImageEditorCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["cropImage"] = MethodMetadata {.argCount = 4, .invoker = __cropImage};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeImageEditorCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __cropImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::cropImage) == 5,
      "Expected cropImage(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::cropImage,  static_cast<NativeImageEditorCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeImageLoaderAndroidImageSize

template <typename P0, typename P1>
struct NativeImageLoaderAndroidImageSize {
  P0 width;
  P1 height;
  bool operator==(const NativeImageLoaderAndroidImageSize &other) const {
    return width == other.width && height == other.height;
  }
};

template <typename T>
struct NativeImageLoaderAndroidImageSizeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }
  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeImageLoaderAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ImageLoader";

protected:
  NativeImageLoaderAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeImageLoaderAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["abortRequest"] = MethodMetadata {.argCount = 1, .invoker = __abortRequest};
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getSize"] = MethodMetadata {.argCount = 1, .invoker = __getSize};
    methodMap_["getSizeWithHeaders"] = MethodMetadata {.argCount = 2, .invoker = __getSizeWithHeaders};
    methodMap_["prefetchImage"] = MethodMetadata {.argCount = 2, .invoker = __prefetchImage};
    methodMap_["queryCache"] = MethodMetadata {.argCount = 1, .invoker = __queryCache};
  }
  
private:
  static jsi::Value __abortRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::abortRequest) == 2,
      "Expected abortRequest(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::abortRequest,  static_cast<NativeImageLoaderAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeImageLoaderAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSize) == 2,
      "Expected getSize(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getSize,  static_cast<NativeImageLoaderAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __getSizeWithHeaders(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
      "Expected getSizeWithHeaders(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getSizeWithHeaders,  static_cast<NativeImageLoaderAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __prefetchImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::prefetchImage) == 3,
      "Expected prefetchImage(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::prefetchImage,  static_cast<NativeImageLoaderAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());
  }

  static jsi::Value __queryCache(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::queryCache) == 2,
      "Expected queryCache(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::queryCache,  static_cast<NativeImageLoaderAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeImageLoaderIOSCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ImageLoader";

protected:
  NativeImageLoaderIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeImageLoaderIOSCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getSize"] = MethodMetadata {.argCount = 1, .invoker = __getSize};
    methodMap_["getSizeWithHeaders"] = MethodMetadata {.argCount = 2, .invoker = __getSizeWithHeaders};
    methodMap_["prefetchImage"] = MethodMetadata {.argCount = 1, .invoker = __prefetchImage};
    methodMap_["prefetchImageWithMetadata"] = MethodMetadata {.argCount = 3, .invoker = __prefetchImageWithMetadata};
    methodMap_["queryCache"] = MethodMetadata {.argCount = 1, .invoker = __queryCache};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeImageLoaderIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSize) == 2,
      "Expected getSize(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getSize,  static_cast<NativeImageLoaderIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __getSizeWithHeaders(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
      "Expected getSizeWithHeaders(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getSizeWithHeaders,  static_cast<NativeImageLoaderIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __prefetchImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::prefetchImage) == 2,
      "Expected prefetchImage(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::prefetchImage,  static_cast<NativeImageLoaderIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __prefetchImageWithMetadata(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::prefetchImageWithMetadata) == 4,
      "Expected prefetchImageWithMetadata(...) to have 4 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::prefetchImageWithMetadata,  static_cast<NativeImageLoaderIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());
  }

  static jsi::Value __queryCache(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::queryCache) == 2,
      "Expected queryCache(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::queryCache,  static_cast<NativeImageLoaderIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));
  }
};


template <typename T>
class JSI_EXPORT NativeImageStoreAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ImageStoreManager";

protected:
  NativeImageStoreAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeImageStoreAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getBase64ForTag"] = MethodMetadata {.argCount = 3, .invoker = __getBase64ForTag};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeImageStoreAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getBase64ForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBase64ForTag) == 4,
      "Expected getBase64ForTag(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::getBase64ForTag,  static_cast<NativeImageStoreAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeImageStoreIOSCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ImageStoreManager";

protected:
  NativeImageStoreIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeImageStoreIOSCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getBase64ForTag"] = MethodMetadata {.argCount = 3, .invoker = __getBase64ForTag};
    methodMap_["hasImageForTag"] = MethodMetadata {.argCount = 2, .invoker = __hasImageForTag};
    methodMap_["removeImageForTag"] = MethodMetadata {.argCount = 1, .invoker = __removeImageForTag};
    methodMap_["addImageFromBase64"] = MethodMetadata {.argCount = 3, .invoker = __addImageFromBase64};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeImageStoreIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getBase64ForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBase64ForTag) == 4,
      "Expected getBase64ForTag(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::getBase64ForTag,  static_cast<NativeImageStoreIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __hasImageForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::hasImageForTag) == 3,
      "Expected hasImageForTag(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::hasImageForTag,  static_cast<NativeImageStoreIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeImageForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeImageForTag) == 2,
      "Expected removeImageForTag(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeImageForTag,  static_cast<NativeImageStoreIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __addImageFromBase64(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addImageFromBase64) == 4,
      "Expected addImageFromBase64(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::addImageFromBase64,  static_cast<NativeImageStoreIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeIntentAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "IntentAndroid";

protected:
  NativeIntentAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeIntentAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getInitialURL"] = MethodMetadata {.argCount = 0, .invoker = __getInitialURL};
    methodMap_["canOpenURL"] = MethodMetadata {.argCount = 1, .invoker = __canOpenURL};
    methodMap_["openURL"] = MethodMetadata {.argCount = 1, .invoker = __openURL};
    methodMap_["openSettings"] = MethodMetadata {.argCount = 0, .invoker = __openSettings};
    methodMap_["sendIntent"] = MethodMetadata {.argCount = 2, .invoker = __sendIntent};
  }
  
private:
  static jsi::Value __getInitialURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getInitialURL) == 1,
      "Expected getInitialURL(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getInitialURL,  static_cast<NativeIntentAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __canOpenURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::canOpenURL) == 2,
      "Expected canOpenURL(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::canOpenURL,  static_cast<NativeIntentAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __openURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::openURL) == 2,
      "Expected openURL(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::openURL,  static_cast<NativeIntentAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __openSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::openSettings) == 1,
      "Expected openSettings(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::openSettings,  static_cast<NativeIntentAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __sendIntent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::sendIntent) == 3,
      "Expected sendIntent(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::sendIntent,  static_cast<NativeIntentAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asObject(rt).asArray(rt)));
  }
};


template <typename T>
class JSI_EXPORT NativeJSCHeapCaptureCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "JSCHeapCapture";

protected:
  NativeJSCHeapCaptureCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeJSCHeapCaptureCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["captureComplete"] = MethodMetadata {.argCount = 2, .invoker = __captureComplete};
  }
  
private:
  static jsi::Value __captureComplete(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::captureComplete) == 3,
      "Expected captureComplete(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::captureComplete,  static_cast<NativeJSCHeapCaptureCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeKeyboardObserverCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "KeyboardObserver";

protected:
  NativeKeyboardObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeKeyboardObserverCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeKeyboardObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeKeyboardObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeLinkingManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "LinkingManager";

protected:
  NativeLinkingManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeLinkingManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getInitialURL"] = MethodMetadata {.argCount = 0, .invoker = __getInitialURL};
    methodMap_["canOpenURL"] = MethodMetadata {.argCount = 1, .invoker = __canOpenURL};
    methodMap_["openURL"] = MethodMetadata {.argCount = 1, .invoker = __openURL};
    methodMap_["openSettings"] = MethodMetadata {.argCount = 0, .invoker = __openSettings};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __getInitialURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getInitialURL) == 1,
      "Expected getInitialURL(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getInitialURL,  static_cast<NativeLinkingManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __canOpenURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::canOpenURL) == 2,
      "Expected canOpenURL(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::canOpenURL,  static_cast<NativeLinkingManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __openURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::openURL) == 2,
      "Expected openURL(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::openURL,  static_cast<NativeLinkingManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __openSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::openSettings) == 1,
      "Expected openSettings(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::openSettings,  static_cast<NativeLinkingManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeLinkingManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeLinkingManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeLogBoxCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "LogBox";

protected:
  NativeLogBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeLogBoxCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["show"] = MethodMetadata {.argCount = 0, .invoker = __show};
    methodMap_["hide"] = MethodMetadata {.argCount = 0, .invoker = __hide};
  }
  
private:
  static jsi::Value __show(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::show) == 1,
      "Expected show(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::show,  static_cast<NativeLogBoxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __hide(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::hide) == 1,
      "Expected hide(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::hide,  static_cast<NativeLogBoxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeModalManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ModalManager";

protected:
  NativeModalManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeModalManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeModalManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeModalManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeNetworkingAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Networking";

protected:
  NativeNetworkingAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeNetworkingAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["sendRequest"] = MethodMetadata {.argCount = 9, .invoker = __sendRequest};
    methodMap_["abortRequest"] = MethodMetadata {.argCount = 1, .invoker = __abortRequest};
    methodMap_["clearCookies"] = MethodMetadata {.argCount = 1, .invoker = __clearCookies};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __sendRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::sendRequest) == 10,
      "Expected sendRequest(...) to have 10 parameters");
    bridging::callFromJs<void>(rt, &T::sendRequest,  static_cast<NativeNetworkingAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asArray(rt),
      count <= 4 ? throw jsi::JSError(rt, "Expected argument in position 4 to be passed") : args[4].asObject(rt),
      count <= 5 ? throw jsi::JSError(rt, "Expected argument in position 5 to be passed") : args[5].asString(rt),
      count <= 6 ? throw jsi::JSError(rt, "Expected argument in position 6 to be passed") : args[6].asBool(),
      count <= 7 ? throw jsi::JSError(rt, "Expected argument in position 7 to be passed") : args[7].asNumber(),
      count <= 8 ? throw jsi::JSError(rt, "Expected argument in position 8 to be passed") : args[8].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __abortRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::abortRequest) == 2,
      "Expected abortRequest(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::abortRequest,  static_cast<NativeNetworkingAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __clearCookies(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::clearCookies) == 2,
      "Expected clearCookies(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::clearCookies,  static_cast<NativeNetworkingAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeNetworkingAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeNetworkingAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeNetworkingIOSCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Networking";

protected:
  NativeNetworkingIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeNetworkingIOSCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["sendRequest"] = MethodMetadata {.argCount = 2, .invoker = __sendRequest};
    methodMap_["abortRequest"] = MethodMetadata {.argCount = 1, .invoker = __abortRequest};
    methodMap_["clearCookies"] = MethodMetadata {.argCount = 1, .invoker = __clearCookies};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __sendRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::sendRequest) == 3,
      "Expected sendRequest(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::sendRequest,  static_cast<NativeNetworkingIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __abortRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::abortRequest) == 2,
      "Expected abortRequest(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::abortRequest,  static_cast<NativeNetworkingIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __clearCookies(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::clearCookies) == 2,
      "Expected clearCookies(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::clearCookies,  static_cast<NativeNetworkingIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeNetworkingIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeNetworkingIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativePermissionsAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "PermissionsAndroid";

protected:
  NativePermissionsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePermissionsAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["checkPermission"] = MethodMetadata {.argCount = 1, .invoker = __checkPermission};
    methodMap_["requestPermission"] = MethodMetadata {.argCount = 1, .invoker = __requestPermission};
    methodMap_["shouldShowRequestPermissionRationale"] = MethodMetadata {.argCount = 1, .invoker = __shouldShowRequestPermissionRationale};
    methodMap_["requestMultiplePermissions"] = MethodMetadata {.argCount = 1, .invoker = __requestMultiplePermissions};
  }
  
private:
  static jsi::Value __checkPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::checkPermission) == 2,
      "Expected checkPermission(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::checkPermission,  static_cast<NativePermissionsAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __requestPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::requestPermission) == 2,
      "Expected requestPermission(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestPermission,  static_cast<NativePermissionsAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __shouldShowRequestPermissionRationale(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::shouldShowRequestPermissionRationale) == 2,
      "Expected shouldShowRequestPermissionRationale(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::shouldShowRequestPermissionRationale,  static_cast<NativePermissionsAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __requestMultiplePermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::requestMultiplePermissions) == 2,
      "Expected requestMultiplePermissions(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestMultiplePermissions,  static_cast<NativePermissionsAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));
  }
};


#pragma mark - NativePlatformConstantsAndroidPlatformConstantsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
struct NativePlatformConstantsAndroidPlatformConstantsAndroid {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 Version;
  P4 Release;
  P5 Serial;
  P6 Fingerprint;
  P7 Model;
  P8 ServerHost;
  P9 uiMode;
  P10 Brand;
  P11 Manufacturer;
  bool operator==(const NativePlatformConstantsAndroidPlatformConstantsAndroid &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && Version == other.Version && Release == other.Release && Serial == other.Serial && Fingerprint == other.Fingerprint && Model == other.Model && ServerHost == other.ServerHost && uiMode == other.uiMode && Brand == other.Brand && Manufacturer == other.Manufacturer;
  }
};

template <typename T>
struct NativePlatformConstantsAndroidPlatformConstantsAndroidBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<decltype(types.Version)>(rt, value.getProperty(rt, "Version"), jsInvoker),
      bridging::fromJs<decltype(types.Release)>(rt, value.getProperty(rt, "Release"), jsInvoker),
      bridging::fromJs<decltype(types.Serial)>(rt, value.getProperty(rt, "Serial"), jsInvoker),
      bridging::fromJs<decltype(types.Fingerprint)>(rt, value.getProperty(rt, "Fingerprint"), jsInvoker),
      bridging::fromJs<decltype(types.Model)>(rt, value.getProperty(rt, "Model"), jsInvoker),
      bridging::fromJs<decltype(types.ServerHost)>(rt, value.getProperty(rt, "ServerHost"), jsInvoker),
      bridging::fromJs<decltype(types.uiMode)>(rt, value.getProperty(rt, "uiMode"), jsInvoker),
      bridging::fromJs<decltype(types.Brand)>(rt, value.getProperty(rt, "Brand"), jsInvoker),
      bridging::fromJs<decltype(types.Manufacturer)>(rt, value.getProperty(rt, "Manufacturer"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
    return bridging::toJs(rt, value);
  }
  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
    return bridging::toJs(rt, value);
  }
  static double VersionToJs(jsi::Runtime &rt, decltype(types.Version) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String ReleaseToJs(jsi::Runtime &rt, decltype(types.Release) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String SerialToJs(jsi::Runtime &rt, decltype(types.Serial) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String FingerprintToJs(jsi::Runtime &rt, decltype(types.Fingerprint) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String ModelToJs(jsi::Runtime &rt, decltype(types.Model) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String ServerHostToJs(jsi::Runtime &rt, decltype(types.ServerHost) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String uiModeToJs(jsi::Runtime &rt, decltype(types.uiMode) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String BrandToJs(jsi::Runtime &rt, decltype(types.Brand) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String ManufacturerToJs(jsi::Runtime &rt, decltype(types.Manufacturer) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "Version", bridging::toJs(rt, value.Version, jsInvoker));
    result.setProperty(rt, "Release", bridging::toJs(rt, value.Release, jsInvoker));
    result.setProperty(rt, "Serial", bridging::toJs(rt, value.Serial, jsInvoker));
    result.setProperty(rt, "Fingerprint", bridging::toJs(rt, value.Fingerprint, jsInvoker));
    result.setProperty(rt, "Model", bridging::toJs(rt, value.Model, jsInvoker));
    if (value.ServerHost) {
      result.setProperty(rt, "ServerHost", bridging::toJs(rt, value.ServerHost.value(), jsInvoker));
    }
    result.setProperty(rt, "uiMode", bridging::toJs(rt, value.uiMode, jsInvoker));
    result.setProperty(rt, "Brand", bridging::toJs(rt, value.Brand, jsInvoker));
    result.setProperty(rt, "Manufacturer", bridging::toJs(rt, value.Manufacturer, jsInvoker));
    return result;
  }
};



#pragma mark - NativePlatformConstantsAndroidReactNativeVersionAndroid

template <typename P0, typename P1, typename P2, typename P3>
struct NativePlatformConstantsAndroidReactNativeVersionAndroid {
  P0 major;
  P1 minor;
  P2 patch;
  P3 prerelease;
  bool operator==(const NativePlatformConstantsAndroidReactNativeVersionAndroid &other) const {
    return major == other.major && minor == other.minor && patch == other.patch && prerelease == other.prerelease;
  }
};

template <typename T>
struct NativePlatformConstantsAndroidReactNativeVersionAndroidBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.major)>(rt, value.getProperty(rt, "major"), jsInvoker),
      bridging::fromJs<decltype(types.minor)>(rt, value.getProperty(rt, "minor"), jsInvoker),
      bridging::fromJs<decltype(types.patch)>(rt, value.getProperty(rt, "patch"), jsInvoker),
      bridging::fromJs<decltype(types.prerelease)>(rt, value.getProperty(rt, "prerelease"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double majorToJs(jsi::Runtime &rt, decltype(types.major) value) {
    return bridging::toJs(rt, value);
  }
  static double minorToJs(jsi::Runtime &rt, decltype(types.minor) value) {
    return bridging::toJs(rt, value);
  }
  static double patchToJs(jsi::Runtime &rt, decltype(types.patch) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> prereleaseToJs(jsi::Runtime &rt, decltype(types.prerelease) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "major", bridging::toJs(rt, value.major, jsInvoker));
    result.setProperty(rt, "minor", bridging::toJs(rt, value.minor, jsInvoker));
    result.setProperty(rt, "patch", bridging::toJs(rt, value.patch, jsInvoker));
    result.setProperty(rt, "prerelease", bridging::toJs(rt, value.prerelease, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativePlatformConstantsAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "PlatformConstants";

protected:
  NativePlatformConstantsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePlatformConstantsAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getAndroidID"] = MethodMetadata {.argCount = 0, .invoker = __getAndroidID};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativePlatformConstantsAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getAndroidID(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getAndroidID) == 1,
      "Expected getAndroidID(...) to have 1 parameters");
    return bridging::callFromJs<jsi::String>(rt, &T::getAndroidID,  static_cast<NativePlatformConstantsAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


#pragma mark - NativePlatformConstantsIOSPlatformConstantsIOS

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct NativePlatformConstantsIOSPlatformConstantsIOS {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 forceTouchAvailable;
  P4 osVersion;
  P5 systemName;
  P6 interfaceIdiom;
  P7 isMacCatalyst;
  bool operator==(const NativePlatformConstantsIOSPlatformConstantsIOS &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && forceTouchAvailable == other.forceTouchAvailable && osVersion == other.osVersion && systemName == other.systemName && interfaceIdiom == other.interfaceIdiom && isMacCatalyst == other.isMacCatalyst;
  }
};

template <typename T>
struct NativePlatformConstantsIOSPlatformConstantsIOSBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<decltype(types.forceTouchAvailable)>(rt, value.getProperty(rt, "forceTouchAvailable"), jsInvoker),
      bridging::fromJs<decltype(types.osVersion)>(rt, value.getProperty(rt, "osVersion"), jsInvoker),
      bridging::fromJs<decltype(types.systemName)>(rt, value.getProperty(rt, "systemName"), jsInvoker),
      bridging::fromJs<decltype(types.interfaceIdiom)>(rt, value.getProperty(rt, "interfaceIdiom"), jsInvoker),
      bridging::fromJs<decltype(types.isMacCatalyst)>(rt, value.getProperty(rt, "isMacCatalyst"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
    return bridging::toJs(rt, value);
  }
  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
    return bridging::toJs(rt, value);
  }
  static bool forceTouchAvailableToJs(jsi::Runtime &rt, decltype(types.forceTouchAvailable) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String osVersionToJs(jsi::Runtime &rt, decltype(types.osVersion) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String systemNameToJs(jsi::Runtime &rt, decltype(types.systemName) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String interfaceIdiomToJs(jsi::Runtime &rt, decltype(types.interfaceIdiom) value) {
    return bridging::toJs(rt, value);
  }
  static bool isMacCatalystToJs(jsi::Runtime &rt, decltype(types.isMacCatalyst) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "forceTouchAvailable", bridging::toJs(rt, value.forceTouchAvailable, jsInvoker));
    result.setProperty(rt, "osVersion", bridging::toJs(rt, value.osVersion, jsInvoker));
    result.setProperty(rt, "systemName", bridging::toJs(rt, value.systemName, jsInvoker));
    result.setProperty(rt, "interfaceIdiom", bridging::toJs(rt, value.interfaceIdiom, jsInvoker));
    if (value.isMacCatalyst) {
      result.setProperty(rt, "isMacCatalyst", bridging::toJs(rt, value.isMacCatalyst.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativePlatformConstantsIOSCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "PlatformConstants";

protected:
  NativePlatformConstantsIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePlatformConstantsIOSCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativePlatformConstantsIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


#pragma mark - NativePushNotificationManagerIOSNotification

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct NativePushNotificationManagerIOSNotification {
  P0 alertTitle;
  P1 alertBody;
  P2 userInfo;
  P3 category;
  P4 fireDate;
  P5 fireIntervalSeconds;
  P6 applicationIconBadgeNumber;
  P7 isSilent;
  P8 soundName;
  bool operator==(const NativePushNotificationManagerIOSNotification &other) const {
    return alertTitle == other.alertTitle && alertBody == other.alertBody && userInfo == other.userInfo && category == other.category && fireDate == other.fireDate && fireIntervalSeconds == other.fireIntervalSeconds && applicationIconBadgeNumber == other.applicationIconBadgeNumber && isSilent == other.isSilent && soundName == other.soundName;
  }
};

template <typename T>
struct NativePushNotificationManagerIOSNotificationBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.alertTitle)>(rt, value.getProperty(rt, "alertTitle"), jsInvoker),
      bridging::fromJs<decltype(types.alertBody)>(rt, value.getProperty(rt, "alertBody"), jsInvoker),
      bridging::fromJs<decltype(types.userInfo)>(rt, value.getProperty(rt, "userInfo"), jsInvoker),
      bridging::fromJs<decltype(types.category)>(rt, value.getProperty(rt, "category"), jsInvoker),
      bridging::fromJs<decltype(types.fireDate)>(rt, value.getProperty(rt, "fireDate"), jsInvoker),
      bridging::fromJs<decltype(types.fireIntervalSeconds)>(rt, value.getProperty(rt, "fireIntervalSeconds"), jsInvoker),
      bridging::fromJs<decltype(types.applicationIconBadgeNumber)>(rt, value.getProperty(rt, "applicationIconBadgeNumber"), jsInvoker),
      bridging::fromJs<decltype(types.isSilent)>(rt, value.getProperty(rt, "isSilent"), jsInvoker),
      bridging::fromJs<decltype(types.soundName)>(rt, value.getProperty(rt, "soundName"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> alertTitleToJs(jsi::Runtime &rt, decltype(types.alertTitle) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> alertBodyToJs(jsi::Runtime &rt, decltype(types.alertBody) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Object> userInfoToJs(jsi::Runtime &rt, decltype(types.userInfo) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> categoryToJs(jsi::Runtime &rt, decltype(types.category) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> fireDateToJs(jsi::Runtime &rt, decltype(types.fireDate) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> fireIntervalSecondsToJs(jsi::Runtime &rt, decltype(types.fireIntervalSeconds) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> applicationIconBadgeNumberToJs(jsi::Runtime &rt, decltype(types.applicationIconBadgeNumber) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<bool> isSilentToJs(jsi::Runtime &rt, decltype(types.isSilent) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> soundNameToJs(jsi::Runtime &rt, decltype(types.soundName) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.alertTitle) {
      result.setProperty(rt, "alertTitle", bridging::toJs(rt, value.alertTitle.value(), jsInvoker));
    }
    if (value.alertBody) {
      result.setProperty(rt, "alertBody", bridging::toJs(rt, value.alertBody.value(), jsInvoker));
    }
    if (value.userInfo) {
      result.setProperty(rt, "userInfo", bridging::toJs(rt, value.userInfo.value(), jsInvoker));
    }
    if (value.category) {
      result.setProperty(rt, "category", bridging::toJs(rt, value.category.value(), jsInvoker));
    }
    if (value.fireDate) {
      result.setProperty(rt, "fireDate", bridging::toJs(rt, value.fireDate.value(), jsInvoker));
    }
    if (value.fireIntervalSeconds) {
      result.setProperty(rt, "fireIntervalSeconds", bridging::toJs(rt, value.fireIntervalSeconds.value(), jsInvoker));
    }
    if (value.applicationIconBadgeNumber) {
      result.setProperty(rt, "applicationIconBadgeNumber", bridging::toJs(rt, value.applicationIconBadgeNumber.value(), jsInvoker));
    }
    if (value.isSilent) {
      result.setProperty(rt, "isSilent", bridging::toJs(rt, value.isSilent.value(), jsInvoker));
    }
    if (value.soundName) {
      result.setProperty(rt, "soundName", bridging::toJs(rt, value.soundName.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativePushNotificationManagerIOSPermissions

template <typename P0, typename P1, typename P2>
struct NativePushNotificationManagerIOSPermissions {
  P0 alert;
  P1 badge;
  P2 sound;
  bool operator==(const NativePushNotificationManagerIOSPermissions &other) const {
    return alert == other.alert && badge == other.badge && sound == other.sound;
  }
};

template <typename T>
struct NativePushNotificationManagerIOSPermissionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.alert)>(rt, value.getProperty(rt, "alert"), jsInvoker),
      bridging::fromJs<decltype(types.badge)>(rt, value.getProperty(rt, "badge"), jsInvoker),
      bridging::fromJs<decltype(types.sound)>(rt, value.getProperty(rt, "sound"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool alertToJs(jsi::Runtime &rt, decltype(types.alert) value) {
    return bridging::toJs(rt, value);
  }
  static bool badgeToJs(jsi::Runtime &rt, decltype(types.badge) value) {
    return bridging::toJs(rt, value);
  }
  static bool soundToJs(jsi::Runtime &rt, decltype(types.sound) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "alert", bridging::toJs(rt, value.alert, jsInvoker));
    result.setProperty(rt, "badge", bridging::toJs(rt, value.badge, jsInvoker));
    result.setProperty(rt, "sound", bridging::toJs(rt, value.sound, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativePushNotificationManagerIOSCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "PushNotificationManager";

protected:
  NativePushNotificationManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePushNotificationManagerIOSCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["onFinishRemoteNotification"] = MethodMetadata {.argCount = 2, .invoker = __onFinishRemoteNotification};
    methodMap_["setApplicationIconBadgeNumber"] = MethodMetadata {.argCount = 1, .invoker = __setApplicationIconBadgeNumber};
    methodMap_["getApplicationIconBadgeNumber"] = MethodMetadata {.argCount = 1, .invoker = __getApplicationIconBadgeNumber};
    methodMap_["requestPermissions"] = MethodMetadata {.argCount = 1, .invoker = __requestPermissions};
    methodMap_["abandonPermissions"] = MethodMetadata {.argCount = 0, .invoker = __abandonPermissions};
    methodMap_["checkPermissions"] = MethodMetadata {.argCount = 1, .invoker = __checkPermissions};
    methodMap_["presentLocalNotification"] = MethodMetadata {.argCount = 1, .invoker = __presentLocalNotification};
    methodMap_["scheduleLocalNotification"] = MethodMetadata {.argCount = 1, .invoker = __scheduleLocalNotification};
    methodMap_["cancelAllLocalNotifications"] = MethodMetadata {.argCount = 0, .invoker = __cancelAllLocalNotifications};
    methodMap_["cancelLocalNotifications"] = MethodMetadata {.argCount = 1, .invoker = __cancelLocalNotifications};
    methodMap_["getInitialNotification"] = MethodMetadata {.argCount = 0, .invoker = __getInitialNotification};
    methodMap_["getScheduledLocalNotifications"] = MethodMetadata {.argCount = 1, .invoker = __getScheduledLocalNotifications};
    methodMap_["removeAllDeliveredNotifications"] = MethodMetadata {.argCount = 0, .invoker = __removeAllDeliveredNotifications};
    methodMap_["removeDeliveredNotifications"] = MethodMetadata {.argCount = 1, .invoker = __removeDeliveredNotifications};
    methodMap_["getDeliveredNotifications"] = MethodMetadata {.argCount = 1, .invoker = __getDeliveredNotifications};
    methodMap_["getAuthorizationStatus"] = MethodMetadata {.argCount = 1, .invoker = __getAuthorizationStatus};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __onFinishRemoteNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::onFinishRemoteNotification) == 3,
      "Expected onFinishRemoteNotification(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::onFinishRemoteNotification,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setApplicationIconBadgeNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setApplicationIconBadgeNumber) == 2,
      "Expected setApplicationIconBadgeNumber(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setApplicationIconBadgeNumber,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __getApplicationIconBadgeNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getApplicationIconBadgeNumber) == 2,
      "Expected getApplicationIconBadgeNumber(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::getApplicationIconBadgeNumber,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __requestPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::requestPermissions) == 2,
      "Expected requestPermissions(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestPermissions,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));
  }

  static jsi::Value __abandonPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::abandonPermissions) == 1,
      "Expected abandonPermissions(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::abandonPermissions,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __checkPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::checkPermissions) == 2,
      "Expected checkPermissions(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::checkPermissions,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __presentLocalNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::presentLocalNotification) == 2,
      "Expected presentLocalNotification(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::presentLocalNotification,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __scheduleLocalNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::scheduleLocalNotification) == 2,
      "Expected scheduleLocalNotification(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::scheduleLocalNotification,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __cancelAllLocalNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::cancelAllLocalNotifications) == 1,
      "Expected cancelAllLocalNotifications(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::cancelAllLocalNotifications,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __cancelLocalNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::cancelLocalNotifications) == 2,
      "Expected cancelLocalNotifications(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::cancelLocalNotifications,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getInitialNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getInitialNotification) == 1,
      "Expected getInitialNotification(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getInitialNotification,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getScheduledLocalNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getScheduledLocalNotifications) == 2,
      "Expected getScheduledLocalNotifications(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::getScheduledLocalNotifications,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeAllDeliveredNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::removeAllDeliveredNotifications) == 1,
      "Expected removeAllDeliveredNotifications(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::removeAllDeliveredNotifications,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __removeDeliveredNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeDeliveredNotifications) == 2,
      "Expected removeDeliveredNotifications(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeDeliveredNotifications,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getDeliveredNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getDeliveredNotifications) == 2,
      "Expected getDeliveredNotifications(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::getDeliveredNotifications,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getAuthorizationStatus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAuthorizationStatus) == 2,
      "Expected getAuthorizationStatus(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::getAuthorizationStatus,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativePushNotificationManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeRedBoxCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RedBox";

protected:
  NativeRedBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeRedBoxCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["setExtraData"] = MethodMetadata {.argCount = 2, .invoker = __setExtraData};
    methodMap_["dismiss"] = MethodMetadata {.argCount = 0, .invoker = __dismiss};
  }
  
private:
  static jsi::Value __setExtraData(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setExtraData) == 3,
      "Expected setExtraData(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setExtraData,  static_cast<NativeRedBoxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __dismiss(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::dismiss) == 1,
      "Expected dismiss(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::dismiss,  static_cast<NativeRedBoxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeSegmentFetcherCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "SegmentFetcher";

protected:
  NativeSegmentFetcherCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSegmentFetcherCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["fetchSegment"] = MethodMetadata {.argCount = 3, .invoker = __fetchSegment};
    methodMap_["getSegment"] = MethodMetadata {.argCount = 3, .invoker = __getSegment};
  }
  
private:
  static jsi::Value __fetchSegment(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::fetchSegment) == 4,
      "Expected fetchSegment(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::fetchSegment,  static_cast<NativeSegmentFetcherCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getSegment(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getSegment) == 4,
      "Expected getSegment(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::getSegment,  static_cast<NativeSegmentFetcherCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeSettingsManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "SettingsManager";

protected:
  NativeSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSettingsManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["setValues"] = MethodMetadata {.argCount = 1, .invoker = __setValues};
    methodMap_["deleteValues"] = MethodMetadata {.argCount = 1, .invoker = __deleteValues};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSettingsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __setValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setValues) == 2,
      "Expected setValues(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setValues,  static_cast<NativeSettingsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __deleteValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::deleteValues) == 2,
      "Expected deleteValues(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::deleteValues,  static_cast<NativeSettingsManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeShareModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ShareModule";

protected:
  NativeShareModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeShareModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["share"] = MethodMetadata {.argCount = 2, .invoker = __share};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeShareModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __share(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::share) == 3,
      "Expected share(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::share,  static_cast<NativeShareModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt)));
  }
};


template <typename T>
class JSI_EXPORT NativeSoundManagerCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "SoundManager";

protected:
  NativeSoundManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSoundManagerCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["playTouchSound"] = MethodMetadata {.argCount = 0, .invoker = __playTouchSound};
  }
  
private:
  static jsi::Value __playTouchSound(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::playTouchSound) == 1,
      "Expected playTouchSound(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::playTouchSound,  static_cast<NativeSoundManagerCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


#pragma mark - NativeSourceCodeSourceCodeConstants

template <typename P0>
struct NativeSourceCodeSourceCodeConstants {
  P0 scriptURL;
  bool operator==(const NativeSourceCodeSourceCodeConstants &other) const {
    return scriptURL == other.scriptURL;
  }
};

template <typename T>
struct NativeSourceCodeSourceCodeConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.scriptURL)>(rt, value.getProperty(rt, "scriptURL"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String scriptURLToJs(jsi::Runtime &rt, decltype(types.scriptURL) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "scriptURL", bridging::toJs(rt, value.scriptURL, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeSourceCodeCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "SourceCode";

protected:
  NativeSourceCodeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeSourceCodeCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeSourceCodeCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "StatusBarManager";

protected:
  NativeStatusBarManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeStatusBarManagerAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["setColor"] = MethodMetadata {.argCount = 2, .invoker = __setColor};
    methodMap_["setTranslucent"] = MethodMetadata {.argCount = 1, .invoker = __setTranslucent};
    methodMap_["setStyle"] = MethodMetadata {.argCount = 1, .invoker = __setStyle};
    methodMap_["setHidden"] = MethodMetadata {.argCount = 1, .invoker = __setHidden};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeStatusBarManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __setColor(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setColor) == 3,
      "Expected setColor(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setColor,  static_cast<NativeStatusBarManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __setTranslucent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setTranslucent) == 2,
      "Expected setTranslucent(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setTranslucent,  static_cast<NativeStatusBarManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __setStyle(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setStyle) == 2,
      "Expected setStyle(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setStyle,  static_cast<NativeStatusBarManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __setHidden(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setHidden) == 2,
      "Expected setHidden(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setHidden,  static_cast<NativeStatusBarManagerAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeStatusBarManagerIOSCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "StatusBarManager";

protected:
  NativeStatusBarManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeStatusBarManagerIOSCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["getHeight"] = MethodMetadata {.argCount = 1, .invoker = __getHeight};
    methodMap_["setNetworkActivityIndicatorVisible"] = MethodMetadata {.argCount = 1, .invoker = __setNetworkActivityIndicatorVisible};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
    methodMap_["setStyle"] = MethodMetadata {.argCount = 2, .invoker = __setStyle};
    methodMap_["setHidden"] = MethodMetadata {.argCount = 2, .invoker = __setHidden};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getHeight(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getHeight) == 2,
      "Expected getHeight(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::getHeight,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setNetworkActivityIndicatorVisible(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setNetworkActivityIndicatorVisible) == 2,
      "Expected setNetworkActivityIndicatorVisible(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setNetworkActivityIndicatorVisible,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setStyle(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setStyle) == 3,
      "Expected setStyle(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setStyle,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __setHidden(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setHidden) == 3,
      "Expected setHidden(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setHidden,  static_cast<NativeStatusBarManagerIOSCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeTimingCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Timing";

protected:
  NativeTimingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeTimingCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["createTimer"] = MethodMetadata {.argCount = 4, .invoker = __createTimer};
    methodMap_["deleteTimer"] = MethodMetadata {.argCount = 1, .invoker = __deleteTimer};
    methodMap_["setSendIdleEvents"] = MethodMetadata {.argCount = 1, .invoker = __setSendIdleEvents};
  }
  
private:
  static jsi::Value __createTimer(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createTimer) == 5,
      "Expected createTimer(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::createTimer,  static_cast<NativeTimingCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __deleteTimer(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::deleteTimer) == 2,
      "Expected deleteTimer(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::deleteTimer,  static_cast<NativeTimingCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setSendIdleEvents(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setSendIdleEvents) == 2,
      "Expected setSendIdleEvents(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setSendIdleEvents,  static_cast<NativeTimingCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeToastAndroidCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "ToastAndroid";

protected:
  NativeToastAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeToastAndroidCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["show"] = MethodMetadata {.argCount = 2, .invoker = __show};
    methodMap_["showWithGravity"] = MethodMetadata {.argCount = 3, .invoker = __showWithGravity};
    methodMap_["showWithGravityAndOffset"] = MethodMetadata {.argCount = 5, .invoker = __showWithGravityAndOffset};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeToastAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __show(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::show) == 3,
      "Expected show(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::show,  static_cast<NativeToastAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __showWithGravity(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::showWithGravity) == 4,
      "Expected showWithGravity(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::showWithGravity,  static_cast<NativeToastAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __showWithGravityAndOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::showWithGravityAndOffset) == 6,
      "Expected showWithGravityAndOffset(...) to have 6 parameters");
    bridging::callFromJs<void>(rt, &T::showWithGravityAndOffset,  static_cast<NativeToastAndroidCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber(),
      count <= 4 ? throw jsi::JSError(rt, "Expected argument in position 4 to be passed") : args[4].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeVibrationCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Vibration";

protected:
  NativeVibrationCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeVibrationCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["vibrate"] = MethodMetadata {.argCount = 1, .invoker = __vibrate};
    methodMap_["vibrateByPattern"] = MethodMetadata {.argCount = 2, .invoker = __vibrateByPattern};
    methodMap_["cancel"] = MethodMetadata {.argCount = 0, .invoker = __cancel};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeVibrationCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __vibrate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::vibrate) == 2,
      "Expected vibrate(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::vibrate,  static_cast<NativeVibrationCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __vibrateByPattern(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::vibrateByPattern) == 3,
      "Expected vibrateByPattern(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::vibrateByPattern,  static_cast<NativeVibrationCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __cancel(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::cancel) == 1,
      "Expected cancel(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::cancel,  static_cast<NativeVibrationCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeWebSocketModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "WebSocketModule";

protected:
  NativeWebSocketModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeWebSocketModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["connect"] = MethodMetadata {.argCount = 4, .invoker = __connect};
    methodMap_["send"] = MethodMetadata {.argCount = 2, .invoker = __send};
    methodMap_["sendBinary"] = MethodMetadata {.argCount = 2, .invoker = __sendBinary};
    methodMap_["ping"] = MethodMetadata {.argCount = 1, .invoker = __ping};
    methodMap_["close"] = MethodMetadata {.argCount = 3, .invoker = __close};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __connect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connect) == 5,
      "Expected connect(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::connect,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asObject(rt).asArray(rt)),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __send(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::send) == 3,
      "Expected send(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::send,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __sendBinary(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::sendBinary) == 3,
      "Expected sendBinary(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::sendBinary,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __ping(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::ping) == 2,
      "Expected ping(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::ping,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __close(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::close) == 4,
      "Expected close(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::close,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeWebSocketModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeCPUTimeCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "CPUTimeCxx";

protected:
  NativeCPUTimeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeCPUTimeCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getCPUTimeNanos"] = MethodMetadata {.argCount = 0, .invoker = __getCPUTimeNanos};
    methodMap_["hasAccurateCPUTimeNanosForBenchmarks"] = MethodMetadata {.argCount = 0, .invoker = __hasAccurateCPUTimeNanosForBenchmarks};
  }
  
private:
  static jsi::Value __getCPUTimeNanos(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getCPUTimeNanos) == 1,
      "Expected getCPUTimeNanos(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::getCPUTimeNanos,  static_cast<NativeCPUTimeCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __hasAccurateCPUTimeNanosForBenchmarks(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::hasAccurateCPUTimeNanosForBenchmarks) == 1,
      "Expected hasAccurateCPUTimeNanosForBenchmarks(...) to have 1 parameters");
    return bridging::callFromJs<bool>(rt, &T::hasAccurateCPUTimeNanosForBenchmarks,  static_cast<NativeCPUTimeCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


#pragma mark - NativeFantomNativeEventCategory

enum class NativeFantomNativeEventCategory { ContinuousStart, ContinuousEnd, Unspecified, Discrete, Continuous, Idle };

template <>
struct Bridging<NativeFantomNativeEventCategory> {
  static NativeFantomNativeEventCategory fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 0) {
      return NativeFantomNativeEventCategory::ContinuousStart;
    } else if (value == 1) {
      return NativeFantomNativeEventCategory::ContinuousEnd;
    } else if (value == 2) {
      return NativeFantomNativeEventCategory::Unspecified;
    } else if (value == 3) {
      return NativeFantomNativeEventCategory::Discrete;
    } else if (value == 4) {
      return NativeFantomNativeEventCategory::Continuous;
    } else if (value == 5) {
      return NativeFantomNativeEventCategory::Idle;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeFantomNativeEventCategory");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeFantomNativeEventCategory value) {
    if (value == NativeFantomNativeEventCategory::ContinuousStart) {
      return bridging::toJs(rt, 0);
    } else if (value == NativeFantomNativeEventCategory::ContinuousEnd) {
      return bridging::toJs(rt, 1);
    } else if (value == NativeFantomNativeEventCategory::Unspecified) {
      return bridging::toJs(rt, 2);
    } else if (value == NativeFantomNativeEventCategory::Discrete) {
      return bridging::toJs(rt, 3);
    } else if (value == NativeFantomNativeEventCategory::Continuous) {
      return bridging::toJs(rt, 4);
    } else if (value == NativeFantomNativeEventCategory::Idle) {
      return bridging::toJs(rt, 5);
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeFantomNativeEventCategory");
    }
  }
};
#pragma mark - NativeFantomImageResponse

template <typename P0, typename P1, typename P2, typename P3>
struct NativeFantomImageResponse {
  P0 width;
  P1 height;
  P2 cacheStatus;
  P3 errorMessage;
  bool operator==(const NativeFantomImageResponse &other) const {
    return width == other.width && height == other.height && cacheStatus == other.cacheStatus && errorMessage == other.errorMessage;
  }
};

template <typename T>
struct NativeFantomImageResponseBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.cacheStatus)>(rt, value.getProperty(rt, "cacheStatus"), jsInvoker),
      bridging::fromJs<decltype(types.errorMessage)>(rt, value.getProperty(rt, "errorMessage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }
  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String cacheStatusToJs(jsi::Runtime &rt, decltype(types.cacheStatus) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String errorMessageToJs(jsi::Runtime &rt, decltype(types.errorMessage) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    if (value.cacheStatus) {
      result.setProperty(rt, "cacheStatus", bridging::toJs(rt, value.cacheStatus.value(), jsInvoker));
    }
    if (value.errorMessage) {
      result.setProperty(rt, "errorMessage", bridging::toJs(rt, value.errorMessage.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeFantomRenderFormatOptions

template <typename P0, typename P1>
struct NativeFantomRenderFormatOptions {
  P0 includeRoot;
  P1 includeLayoutMetrics;
  bool operator==(const NativeFantomRenderFormatOptions &other) const {
    return includeRoot == other.includeRoot && includeLayoutMetrics == other.includeLayoutMetrics;
  }
};

template <typename T>
struct NativeFantomRenderFormatOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.includeRoot)>(rt, value.getProperty(rt, "includeRoot"), jsInvoker),
      bridging::fromJs<decltype(types.includeLayoutMetrics)>(rt, value.getProperty(rt, "includeLayoutMetrics"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool includeRootToJs(jsi::Runtime &rt, decltype(types.includeRoot) value) {
    return bridging::toJs(rt, value);
  }
  static bool includeLayoutMetricsToJs(jsi::Runtime &rt, decltype(types.includeLayoutMetrics) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "includeRoot", bridging::toJs(rt, value.includeRoot, jsInvoker));
    result.setProperty(rt, "includeLayoutMetrics", bridging::toJs(rt, value.includeLayoutMetrics, jsInvoker));
    return result;
  }
};



#pragma mark - NativeFantomScrollOptions

template <typename P0, typename P1, typename P2>
struct NativeFantomScrollOptions {
  P0 x;
  P1 y;
  P2 zoomScale;
  bool operator==(const NativeFantomScrollOptions &other) const {
    return x == other.x && y == other.y && zoomScale == other.zoomScale;
  }
};

template <typename T>
struct NativeFantomScrollOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.x)>(rt, value.getProperty(rt, "x"), jsInvoker),
      bridging::fromJs<decltype(types.y)>(rt, value.getProperty(rt, "y"), jsInvoker),
      bridging::fromJs<decltype(types.zoomScale)>(rt, value.getProperty(rt, "zoomScale"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double xToJs(jsi::Runtime &rt, decltype(types.x) value) {
    return bridging::toJs(rt, value);
  }
  static double yToJs(jsi::Runtime &rt, decltype(types.y) value) {
    return bridging::toJs(rt, value);
  }
  static double zoomScaleToJs(jsi::Runtime &rt, decltype(types.zoomScale) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "x", bridging::toJs(rt, value.x, jsInvoker));
    result.setProperty(rt, "y", bridging::toJs(rt, value.y, jsInvoker));
    if (value.zoomScale) {
      result.setProperty(rt, "zoomScale", bridging::toJs(rt, value.zoomScale.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeFantomCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeFantomCxx";

protected:
  NativeFantomCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeFantomCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["startSurface"] = MethodMetadata {.argCount = 5, .invoker = __startSurface};
    methodMap_["stopSurface"] = MethodMetadata {.argCount = 1, .invoker = __stopSurface};
    methodMap_["enqueueNativeEvent"] = MethodMetadata {.argCount = 5, .invoker = __enqueueNativeEvent};
    methodMap_["enqueueScrollEvent"] = MethodMetadata {.argCount = 2, .invoker = __enqueueScrollEvent};
    methodMap_["enqueueModalSizeUpdate"] = MethodMetadata {.argCount = 3, .invoker = __enqueueModalSizeUpdate};
    methodMap_["takeMountingManagerLogs"] = MethodMetadata {.argCount = 1, .invoker = __takeMountingManagerLogs};
    methodMap_["getDirectManipulationProps"] = MethodMetadata {.argCount = 1, .invoker = __getDirectManipulationProps};
    methodMap_["getFabricUpdateProps"] = MethodMetadata {.argCount = 1, .invoker = __getFabricUpdateProps};
    methodMap_["flushMessageQueue"] = MethodMetadata {.argCount = 0, .invoker = __flushMessageQueue};
    methodMap_["flushEventQueue"] = MethodMetadata {.argCount = 0, .invoker = __flushEventQueue};
    methodMap_["produceFramesForDuration"] = MethodMetadata {.argCount = 1, .invoker = __produceFramesForDuration};
    methodMap_["validateEmptyMessageQueue"] = MethodMetadata {.argCount = 0, .invoker = __validateEmptyMessageQueue};
    methodMap_["getRenderedOutput"] = MethodMetadata {.argCount = 2, .invoker = __getRenderedOutput};
    methodMap_["reportTestSuiteResultsJSON"] = MethodMetadata {.argCount = 1, .invoker = __reportTestSuiteResultsJSON};
    methodMap_["createShadowNodeReferenceCounter"] = MethodMetadata {.argCount = 1, .invoker = __createShadowNodeReferenceCounter};
    methodMap_["createShadowNodeRevisionGetter"] = MethodMetadata {.argCount = 1, .invoker = __createShadowNodeRevisionGetter};
    methodMap_["saveJSMemoryHeapSnapshot"] = MethodMetadata {.argCount = 1, .invoker = __saveJSMemoryHeapSnapshot};
    methodMap_["forceHighResTimeStamp"] = MethodMetadata {.argCount = 1, .invoker = __forceHighResTimeStamp};
    methodMap_["startJSSamplingProfiler"] = MethodMetadata {.argCount = 0, .invoker = __startJSSamplingProfiler};
    methodMap_["stopJSSamplingProfilerAndSaveToFile"] = MethodMetadata {.argCount = 1, .invoker = __stopJSSamplingProfilerAndSaveToFile};
    methodMap_["setImageResponse"] = MethodMetadata {.argCount = 2, .invoker = __setImageResponse};
    methodMap_["clearImage"] = MethodMetadata {.argCount = 1, .invoker = __clearImage};
    methodMap_["clearAllImages"] = MethodMetadata {.argCount = 0, .invoker = __clearAllImages};
  }
  
private:
  static jsi::Value __startSurface(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::startSurface) == 6,
      "Expected startSurface(...) to have 6 parameters");
    return bridging::callFromJs<double>(rt, &T::startSurface,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
      count <= 3 || args[3].isUndefined() ? std::nullopt : std::make_optional(args[3].asNumber()),
      count <= 4 || args[4].isUndefined() ? std::nullopt : std::make_optional(args[4].asNumber()));
  }

  static jsi::Value __stopSurface(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::stopSurface) == 2,
      "Expected stopSurface(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::stopSurface,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __enqueueNativeEvent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::enqueueNativeEvent) == 6,
      "Expected enqueueNativeEvent(...) to have 6 parameters");
    bridging::callFromJs<void>(rt, &T::enqueueNativeEvent,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(jsi::Value(rt, args[2])),
      count <= 3 || args[3].isUndefined() ? std::nullopt : std::make_optional(args[3].asNumber()),
      count <= 4 || args[4].isUndefined() ? std::nullopt : std::make_optional(args[4].asBool()));return jsi::Value::undefined();
  }

  static jsi::Value __enqueueScrollEvent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::enqueueScrollEvent) == 3,
      "Expected enqueueScrollEvent(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::enqueueScrollEvent,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __enqueueModalSizeUpdate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::enqueueModalSizeUpdate) == 4,
      "Expected enqueueModalSizeUpdate(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::enqueueModalSizeUpdate,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __takeMountingManagerLogs(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::takeMountingManagerLogs) == 2,
      "Expected takeMountingManagerLogs(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::takeMountingManagerLogs,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());
  }

  static jsi::Value __getDirectManipulationProps(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getDirectManipulationProps) == 2,
      "Expected getDirectManipulationProps(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getDirectManipulationProps,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getFabricUpdateProps(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getFabricUpdateProps) == 2,
      "Expected getFabricUpdateProps(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getFabricUpdateProps,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __flushMessageQueue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::flushMessageQueue) == 1,
      "Expected flushMessageQueue(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::flushMessageQueue,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __flushEventQueue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::flushEventQueue) == 1,
      "Expected flushEventQueue(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::flushEventQueue,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __produceFramesForDuration(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::produceFramesForDuration) == 2,
      "Expected produceFramesForDuration(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::produceFramesForDuration,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __validateEmptyMessageQueue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::validateEmptyMessageQueue) == 1,
      "Expected validateEmptyMessageQueue(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::validateEmptyMessageQueue,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getRenderedOutput(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getRenderedOutput) == 3,
      "Expected getRenderedOutput(...) to have 3 parameters");
    return bridging::callFromJs<jsi::String>(rt, &T::getRenderedOutput,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __reportTestSuiteResultsJSON(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reportTestSuiteResultsJSON) == 2,
      "Expected reportTestSuiteResultsJSON(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::reportTestSuiteResultsJSON,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __createShadowNodeReferenceCounter(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createShadowNodeReferenceCounter) == 2,
      "Expected createShadowNodeReferenceCounter(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Function>(rt, &T::createShadowNodeReferenceCounter,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __createShadowNodeRevisionGetter(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createShadowNodeRevisionGetter) == 2,
      "Expected createShadowNodeRevisionGetter(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Function>(rt, &T::createShadowNodeRevisionGetter,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __saveJSMemoryHeapSnapshot(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::saveJSMemoryHeapSnapshot) == 2,
      "Expected saveJSMemoryHeapSnapshot(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::saveJSMemoryHeapSnapshot,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __forceHighResTimeStamp(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::forceHighResTimeStamp) == 2,
      "Expected forceHighResTimeStamp(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::forceHighResTimeStamp,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asNumber()));return jsi::Value::undefined();
  }

  static jsi::Value __startJSSamplingProfiler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::startJSSamplingProfiler) == 1,
      "Expected startJSSamplingProfiler(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::startJSSamplingProfiler,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __stopJSSamplingProfilerAndSaveToFile(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::stopJSSamplingProfilerAndSaveToFile) == 2,
      "Expected stopJSSamplingProfilerAndSaveToFile(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::stopJSSamplingProfilerAndSaveToFile,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setImageResponse(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setImageResponse) == 3,
      "Expected setImageResponse(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setImageResponse,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __clearImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::clearImage) == 2,
      "Expected clearImage(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::clearImage,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __clearAllImages(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::clearAllImages) == 1,
      "Expected clearAllImages(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::clearAllImages,  static_cast<NativeFantomCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeFantomTestSpecificMethodsCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeFantomTestSpecificMethodsCxx";

protected:
  NativeFantomTestSpecificMethodsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeFantomTestSpecificMethodsCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["registerForcedCloneCommitHook"] = MethodMetadata {.argCount = 0, .invoker = __registerForcedCloneCommitHook};
    methodMap_["takeFunctionAndNoop"] = MethodMetadata {.argCount = 1, .invoker = __takeFunctionAndNoop};
  }
  
private:
  static jsi::Value __registerForcedCloneCommitHook(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::registerForcedCloneCommitHook) == 1,
      "Expected registerForcedCloneCommitHook(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::registerForcedCloneCommitHook,  static_cast<NativeFantomTestSpecificMethodsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __takeFunctionAndNoop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::takeFunctionAndNoop) == 2,
      "Expected takeFunctionAndNoop(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::takeFunctionAndNoop,  static_cast<NativeFantomTestSpecificMethodsCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeDOMCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeDOMCxx";

protected:
  NativeDOMCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeDOMCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["compareDocumentPosition"] = MethodMetadata {.argCount = 2, .invoker = __compareDocumentPosition};
    methodMap_["getChildNodes"] = MethodMetadata {.argCount = 1, .invoker = __getChildNodes};
    methodMap_["getElementById"] = MethodMetadata {.argCount = 2, .invoker = __getElementById};
    methodMap_["getParentNode"] = MethodMetadata {.argCount = 1, .invoker = __getParentNode};
    methodMap_["isConnected"] = MethodMetadata {.argCount = 1, .invoker = __isConnected};
    methodMap_["getBorderWidth"] = MethodMetadata {.argCount = 1, .invoker = __getBorderWidth};
    methodMap_["getBoundingClientRect"] = MethodMetadata {.argCount = 2, .invoker = __getBoundingClientRect};
    methodMap_["getInnerSize"] = MethodMetadata {.argCount = 1, .invoker = __getInnerSize};
    methodMap_["getScrollPosition"] = MethodMetadata {.argCount = 1, .invoker = __getScrollPosition};
    methodMap_["getScrollSize"] = MethodMetadata {.argCount = 1, .invoker = __getScrollSize};
    methodMap_["getTagName"] = MethodMetadata {.argCount = 1, .invoker = __getTagName};
    methodMap_["getTextContent"] = MethodMetadata {.argCount = 1, .invoker = __getTextContent};
    methodMap_["hasPointerCapture"] = MethodMetadata {.argCount = 2, .invoker = __hasPointerCapture};
    methodMap_["releasePointerCapture"] = MethodMetadata {.argCount = 2, .invoker = __releasePointerCapture};
    methodMap_["setPointerCapture"] = MethodMetadata {.argCount = 2, .invoker = __setPointerCapture};
    methodMap_["getOffset"] = MethodMetadata {.argCount = 1, .invoker = __getOffset};
    methodMap_["linkRootNode"] = MethodMetadata {.argCount = 2, .invoker = __linkRootNode};
    methodMap_["measure"] = MethodMetadata {.argCount = 2, .invoker = __measure};
    methodMap_["measureInWindow"] = MethodMetadata {.argCount = 2, .invoker = __measureInWindow};
    methodMap_["measureLayout"] = MethodMetadata {.argCount = 4, .invoker = __measureLayout};
    methodMap_["setNativeProps"] = MethodMetadata {.argCount = 2, .invoker = __setNativeProps};
  }
  
private:
  static jsi::Value __compareDocumentPosition(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::compareDocumentPosition) == 3,
      "Expected compareDocumentPosition(...) to have 3 parameters");
    return bridging::callFromJs<double>(rt, &T::compareDocumentPosition,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]));
  }

  static jsi::Value __getChildNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getChildNodes) == 2,
      "Expected getChildNodes(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getChildNodes,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getElementById(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getElementById) == 3,
      "Expected getElementById(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getElementById,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));
  }

  static jsi::Value __getParentNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getParentNode) == 2,
      "Expected getParentNode(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getParentNode,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __isConnected(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::isConnected) == 2,
      "Expected isConnected(...) to have 2 parameters");
    return bridging::callFromJs<bool>(rt, &T::isConnected,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getBorderWidth(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBorderWidth) == 2,
      "Expected getBorderWidth(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getBorderWidth,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getBoundingClientRect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBoundingClientRect) == 3,
      "Expected getBoundingClientRect(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getBoundingClientRect,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());
  }

  static jsi::Value __getInnerSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getInnerSize) == 2,
      "Expected getInnerSize(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getInnerSize,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getScrollPosition(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getScrollPosition) == 2,
      "Expected getScrollPosition(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getScrollPosition,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getScrollSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getScrollSize) == 2,
      "Expected getScrollSize(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getScrollSize,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getTagName(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getTagName) == 2,
      "Expected getTagName(...) to have 2 parameters");
    return bridging::callFromJs<jsi::String>(rt, &T::getTagName,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __getTextContent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getTextContent) == 2,
      "Expected getTextContent(...) to have 2 parameters");
    return bridging::callFromJs<jsi::String>(rt, &T::getTextContent,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __hasPointerCapture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::hasPointerCapture) == 3,
      "Expected hasPointerCapture(...) to have 3 parameters");
    return bridging::callFromJs<bool>(rt, &T::hasPointerCapture,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());
  }

  static jsi::Value __releasePointerCapture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::releasePointerCapture) == 3,
      "Expected releasePointerCapture(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::releasePointerCapture,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setPointerCapture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setPointerCapture) == 3,
      "Expected setPointerCapture(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setPointerCapture,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __getOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getOffset) == 2,
      "Expected getOffset(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getOffset,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __linkRootNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::linkRootNode) == 3,
      "Expected linkRootNode(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::linkRootNode,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]));
  }

  static jsi::Value __measure(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::measure) == 3,
      "Expected measure(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::measure,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __measureInWindow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::measureInWindow) == 3,
      "Expected measureInWindow(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::measureInWindow,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __measureLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::measureLayout) == 5,
      "Expected measureLayout(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::measureLayout,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setNativeProps(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setNativeProps) == 3,
      "Expected setNativeProps(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setNativeProps,  static_cast<NativeDOMCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]));return jsi::Value::undefined();
  }
};


#pragma mark - NativeIdleCallbacksIdleDeadline

template <typename P0, typename P1>
struct NativeIdleCallbacksIdleDeadline {
  P0 didTimeout;
  P1 timeRemaining;
  bool operator==(const NativeIdleCallbacksIdleDeadline &other) const {
    return didTimeout == other.didTimeout && timeRemaining == other.timeRemaining;
  }
};

template <typename T>
struct NativeIdleCallbacksIdleDeadlineBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.didTimeout)>(rt, value.getProperty(rt, "didTimeout"), jsInvoker),
      bridging::fromJs<decltype(types.timeRemaining)>(rt, value.getProperty(rt, "timeRemaining"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool didTimeoutToJs(jsi::Runtime &rt, decltype(types.didTimeout) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Function timeRemainingToJs(jsi::Runtime &rt, decltype(types.timeRemaining) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "didTimeout", bridging::toJs(rt, value.didTimeout, jsInvoker));
    result.setProperty(rt, "timeRemaining", bridging::toJs(rt, value.timeRemaining, jsInvoker));
    return result;
  }
};



#pragma mark - NativeIdleCallbacksRequestIdleCallbackOptions

template <typename P0>
struct NativeIdleCallbacksRequestIdleCallbackOptions {
  P0 timeout;
  bool operator==(const NativeIdleCallbacksRequestIdleCallbackOptions &other) const {
    return timeout == other.timeout;
  }
};

template <typename T>
struct NativeIdleCallbacksRequestIdleCallbackOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.timeout)>(rt, value.getProperty(rt, "timeout"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double timeoutToJs(jsi::Runtime &rt, decltype(types.timeout) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.timeout) {
      result.setProperty(rt, "timeout", bridging::toJs(rt, value.timeout.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeIdleCallbacksCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeIdleCallbacksCxx";

protected:
  NativeIdleCallbacksCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeIdleCallbacksCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["requestIdleCallback"] = MethodMetadata {.argCount = 2, .invoker = __requestIdleCallback};
    methodMap_["cancelIdleCallback"] = MethodMetadata {.argCount = 1, .invoker = __cancelIdleCallback};
  }
  
private:
  static jsi::Value __requestIdleCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::requestIdleCallback) == 3,
      "Expected requestIdleCallback(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestIdleCallback,  static_cast<NativeIdleCallbacksCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asObject(rt)));
  }

  static jsi::Value __cancelIdleCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::cancelIdleCallback) == 2,
      "Expected cancelIdleCallback(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::cancelIdleCallback,  static_cast<NativeIdleCallbacksCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));return jsi::Value::undefined();
  }
};


#pragma mark - NativeIntersectionObserverNativeIntersectionObserverEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativeIntersectionObserverNativeIntersectionObserverEntry {
  P0 intersectionObserverId;
  P1 targetInstanceHandle;
  P2 targetRect;
  P3 rootRect;
  P4 intersectionRect;
  P5 isIntersectingAboveThresholds;
  P6 time;
  bool operator==(const NativeIntersectionObserverNativeIntersectionObserverEntry &other) const {
    return intersectionObserverId == other.intersectionObserverId && targetInstanceHandle == other.targetInstanceHandle && targetRect == other.targetRect && rootRect == other.rootRect && intersectionRect == other.intersectionRect && isIntersectingAboveThresholds == other.isIntersectingAboveThresholds && time == other.time;
  }
};

template <typename T>
struct NativeIntersectionObserverNativeIntersectionObserverEntryBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.intersectionObserverId)>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.targetInstanceHandle)>(rt, value.getProperty(rt, "targetInstanceHandle"), jsInvoker),
      bridging::fromJs<decltype(types.targetRect)>(rt, value.getProperty(rt, "targetRect"), jsInvoker),
      bridging::fromJs<decltype(types.rootRect)>(rt, value.getProperty(rt, "rootRect"), jsInvoker),
      bridging::fromJs<decltype(types.intersectionRect)>(rt, value.getProperty(rt, "intersectionRect"), jsInvoker),
      bridging::fromJs<decltype(types.isIntersectingAboveThresholds)>(rt, value.getProperty(rt, "isIntersectingAboveThresholds"), jsInvoker),
      bridging::fromJs<decltype(types.time)>(rt, value.getProperty(rt, "time"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double intersectionObserverIdToJs(jsi::Runtime &rt, decltype(types.intersectionObserverId) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Value targetInstanceHandleToJs(jsi::Runtime &rt, decltype(types.targetInstanceHandle) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array targetRectToJs(jsi::Runtime &rt, decltype(types.targetRect) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array rootRectToJs(jsi::Runtime &rt, decltype(types.rootRect) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Array> intersectionRectToJs(jsi::Runtime &rt, decltype(types.intersectionRect) value) {
    return bridging::toJs(rt, value);
  }
  static bool isIntersectingAboveThresholdsToJs(jsi::Runtime &rt, decltype(types.isIntersectingAboveThresholds) value) {
    return bridging::toJs(rt, value);
  }
  static double timeToJs(jsi::Runtime &rt, decltype(types.time) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
    result.setProperty(rt, "targetInstanceHandle", bridging::toJs(rt, value.targetInstanceHandle, jsInvoker));
    result.setProperty(rt, "targetRect", bridging::toJs(rt, value.targetRect, jsInvoker));
    result.setProperty(rt, "rootRect", bridging::toJs(rt, value.rootRect, jsInvoker));
    result.setProperty(rt, "intersectionRect", bridging::toJs(rt, value.intersectionRect, jsInvoker));
    result.setProperty(rt, "isIntersectingAboveThresholds", bridging::toJs(rt, value.isIntersectingAboveThresholds, jsInvoker));
    result.setProperty(rt, "time", bridging::toJs(rt, value.time, jsInvoker));
    return result;
  }
};



#pragma mark - NativeIntersectionObserverNativeIntersectionObserverObserveOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeIntersectionObserverNativeIntersectionObserverObserveOptions {
  P0 intersectionObserverId;
  P1 rootShadowNode;
  P2 targetShadowNode;
  P3 thresholds;
  P4 rootThresholds;
  P5 rootMargin;
  bool operator==(const NativeIntersectionObserverNativeIntersectionObserverObserveOptions &other) const {
    return intersectionObserverId == other.intersectionObserverId && rootShadowNode == other.rootShadowNode && targetShadowNode == other.targetShadowNode && thresholds == other.thresholds && rootThresholds == other.rootThresholds && rootMargin == other.rootMargin;
  }
};

template <typename T>
struct NativeIntersectionObserverNativeIntersectionObserverObserveOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.intersectionObserverId)>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.rootShadowNode)>(rt, value.getProperty(rt, "rootShadowNode"), jsInvoker),
      bridging::fromJs<decltype(types.targetShadowNode)>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
      bridging::fromJs<decltype(types.thresholds)>(rt, value.getProperty(rt, "thresholds"), jsInvoker),
      bridging::fromJs<decltype(types.rootThresholds)>(rt, value.getProperty(rt, "rootThresholds"), jsInvoker),
      bridging::fromJs<decltype(types.rootMargin)>(rt, value.getProperty(rt, "rootMargin"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double intersectionObserverIdToJs(jsi::Runtime &rt, decltype(types.intersectionObserverId) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Value> rootShadowNodeToJs(jsi::Runtime &rt, decltype(types.rootShadowNode) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, decltype(types.targetShadowNode) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array thresholdsToJs(jsi::Runtime &rt, decltype(types.thresholds) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Array> rootThresholdsToJs(jsi::Runtime &rt, decltype(types.rootThresholds) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> rootMarginToJs(jsi::Runtime &rt, decltype(types.rootMargin) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
    if (value.rootShadowNode) {
      result.setProperty(rt, "rootShadowNode", bridging::toJs(rt, value.rootShadowNode.value(), jsInvoker));
    }
    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
    result.setProperty(rt, "thresholds", bridging::toJs(rt, value.thresholds, jsInvoker));
    if (value.rootThresholds) {
      result.setProperty(rt, "rootThresholds", bridging::toJs(rt, value.rootThresholds.value(), jsInvoker));
    }
    if (value.rootMargin) {
      result.setProperty(rt, "rootMargin", bridging::toJs(rt, value.rootMargin.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeIntersectionObserverCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeIntersectionObserverCxx";

protected:
  NativeIntersectionObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeIntersectionObserverCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["observeV2"] = MethodMetadata {.argCount = 1, .invoker = __observeV2};
    methodMap_["unobserveV2"] = MethodMetadata {.argCount = 2, .invoker = __unobserveV2};
    methodMap_["connect"] = MethodMetadata {.argCount = 1, .invoker = __connect};
    methodMap_["disconnect"] = MethodMetadata {.argCount = 0, .invoker = __disconnect};
    methodMap_["takeRecords"] = MethodMetadata {.argCount = 0, .invoker = __takeRecords};
  }
  
private:
  static jsi::Value __observeV2(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::observeV2) == 2,
      "Expected observeV2(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::observeV2,  static_cast<NativeIntersectionObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));
  }

  static jsi::Value __unobserveV2(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::unobserveV2) == 3,
      "Expected unobserveV2(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::unobserveV2,  static_cast<NativeIntersectionObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]));return jsi::Value::undefined();
  }

  static jsi::Value __connect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connect) == 2,
      "Expected connect(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::connect,  static_cast<NativeIntersectionObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __disconnect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disconnect) == 1,
      "Expected disconnect(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::disconnect,  static_cast<NativeIntersectionObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __takeRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::takeRecords) == 1,
      "Expected takeRecords(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::takeRecords,  static_cast<NativeIntersectionObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeMicrotasksCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeMicrotasksCxx";

protected:
  NativeMicrotasksCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeMicrotasksCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["queueMicrotask"] = MethodMetadata {.argCount = 1, .invoker = __queueMicrotask};
  }
  
private:
  static jsi::Value __queueMicrotask(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::queueMicrotask) == 2,
      "Expected queueMicrotask(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::queueMicrotask,  static_cast<NativeMicrotasksCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }
};


#pragma mark - NativeMutationObserverNativeMutationObserverObserveOptions

template <typename P0, typename P1, typename P2>
struct NativeMutationObserverNativeMutationObserverObserveOptions {
  P0 mutationObserverId;
  P1 targetShadowNode;
  P2 subtree;
  bool operator==(const NativeMutationObserverNativeMutationObserverObserveOptions &other) const {
    return mutationObserverId == other.mutationObserverId && targetShadowNode == other.targetShadowNode && subtree == other.subtree;
  }
};

template <typename T>
struct NativeMutationObserverNativeMutationObserverObserveOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mutationObserverId)>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.targetShadowNode)>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
      bridging::fromJs<decltype(types.subtree)>(rt, value.getProperty(rt, "subtree"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double mutationObserverIdToJs(jsi::Runtime &rt, decltype(types.mutationObserverId) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, decltype(types.targetShadowNode) value) {
    return bridging::toJs(rt, value);
  }
  static bool subtreeToJs(jsi::Runtime &rt, decltype(types.subtree) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
    result.setProperty(rt, "subtree", bridging::toJs(rt, value.subtree, jsInvoker));
    return result;
  }
};



#pragma mark - NativeMutationObserverNativeMutationRecord

template <typename P0, typename P1, typename P2, typename P3>
struct NativeMutationObserverNativeMutationRecord {
  P0 mutationObserverId;
  P1 target;
  P2 addedNodes;
  P3 removedNodes;
  bool operator==(const NativeMutationObserverNativeMutationRecord &other) const {
    return mutationObserverId == other.mutationObserverId && target == other.target && addedNodes == other.addedNodes && removedNodes == other.removedNodes;
  }
};

template <typename T>
struct NativeMutationObserverNativeMutationRecordBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mutationObserverId)>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.target)>(rt, value.getProperty(rt, "target"), jsInvoker),
      bridging::fromJs<decltype(types.addedNodes)>(rt, value.getProperty(rt, "addedNodes"), jsInvoker),
      bridging::fromJs<decltype(types.removedNodes)>(rt, value.getProperty(rt, "removedNodes"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double mutationObserverIdToJs(jsi::Runtime &rt, decltype(types.mutationObserverId) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Value targetToJs(jsi::Runtime &rt, decltype(types.target) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array addedNodesToJs(jsi::Runtime &rt, decltype(types.addedNodes) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array removedNodesToJs(jsi::Runtime &rt, decltype(types.removedNodes) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
    result.setProperty(rt, "target", bridging::toJs(rt, value.target, jsInvoker));
    result.setProperty(rt, "addedNodes", bridging::toJs(rt, value.addedNodes, jsInvoker));
    result.setProperty(rt, "removedNodes", bridging::toJs(rt, value.removedNodes, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeMutationObserverCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativeMutationObserverCxx";

protected:
  NativeMutationObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeMutationObserverCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["observe"] = MethodMetadata {.argCount = 1, .invoker = __observe};
    methodMap_["unobserveAll"] = MethodMetadata {.argCount = 1, .invoker = __unobserveAll};
    methodMap_["connect"] = MethodMetadata {.argCount = 2, .invoker = __connect};
    methodMap_["disconnect"] = MethodMetadata {.argCount = 0, .invoker = __disconnect};
    methodMap_["takeRecords"] = MethodMetadata {.argCount = 0, .invoker = __takeRecords};
  }
  
private:
  static jsi::Value __observe(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::observe) == 2,
      "Expected observe(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::observe,  static_cast<NativeMutationObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __unobserveAll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::unobserveAll) == 2,
      "Expected unobserveAll(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::unobserveAll,  static_cast<NativeMutationObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __connect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::connect) == 3,
      "Expected connect(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::connect,  static_cast<NativeMutationObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __disconnect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::disconnect) == 1,
      "Expected disconnect(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::disconnect,  static_cast<NativeMutationObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __takeRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::takeRecords) == 1,
      "Expected takeRecords(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::takeRecords,  static_cast<NativeMutationObserverCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};



#pragma mark - NativePerformancePerformanceObserverInit

template <typename P0, typename P1, typename P2, typename P3>
struct NativePerformancePerformanceObserverInit {
  P0 entryTypes;
  P1 type;
  P2 buffered;
  P3 durationThreshold;
  bool operator==(const NativePerformancePerformanceObserverInit &other) const {
    return entryTypes == other.entryTypes && type == other.type && buffered == other.buffered && durationThreshold == other.durationThreshold;
  }
};

template <typename T>
struct NativePerformancePerformanceObserverInitBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.entryTypes)>(rt, value.getProperty(rt, "entryTypes"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.buffered)>(rt, value.getProperty(rt, "buffered"), jsInvoker),
      bridging::fromJs<decltype(types.durationThreshold)>(rt, value.getProperty(rt, "durationThreshold"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array entryTypesToJs(jsi::Runtime &rt, decltype(types.entryTypes) value) {
    return bridging::toJs(rt, value);
  }
  static double typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }
  static bool bufferedToJs(jsi::Runtime &rt, decltype(types.buffered) value) {
    return bridging::toJs(rt, value);
  }
  static double durationThresholdToJs(jsi::Runtime &rt, decltype(types.durationThreshold) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.entryTypes) {
      result.setProperty(rt, "entryTypes", bridging::toJs(rt, value.entryTypes.value(), jsInvoker));
    }
    if (value.type) {
      result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
    }
    if (value.buffered) {
      result.setProperty(rt, "buffered", bridging::toJs(rt, value.buffered.value(), jsInvoker));
    }
    if (value.durationThreshold) {
      result.setProperty(rt, "durationThreshold", bridging::toJs(rt, value.durationThreshold.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativePerformanceRawPerformanceEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16>
struct NativePerformanceRawPerformanceEntry {
  P0 name;
  P1 entryType;
  P2 startTime;
  P3 duration;
  P4 processingStart;
  P5 processingEnd;
  P6 interactionId;
  P7 fetchStart;
  P8 requestStart;
  P9 connectStart;
  P10 connectEnd;
  P11 responseStart;
  P12 responseEnd;
  P13 responseStatus;
  P14 contentType;
  P15 encodedBodySize;
  P16 decodedBodySize;
  bool operator==(const NativePerformanceRawPerformanceEntry &other) const {
    return name == other.name && entryType == other.entryType && startTime == other.startTime && duration == other.duration && processingStart == other.processingStart && processingEnd == other.processingEnd && interactionId == other.interactionId && fetchStart == other.fetchStart && requestStart == other.requestStart && connectStart == other.connectStart && connectEnd == other.connectEnd && responseStart == other.responseStart && responseEnd == other.responseEnd && responseStatus == other.responseStatus && contentType == other.contentType && encodedBodySize == other.encodedBodySize && decodedBodySize == other.decodedBodySize;
  }
};

template <typename T>
struct NativePerformanceRawPerformanceEntryBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.entryType)>(rt, value.getProperty(rt, "entryType"), jsInvoker),
      bridging::fromJs<decltype(types.startTime)>(rt, value.getProperty(rt, "startTime"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<decltype(types.processingStart)>(rt, value.getProperty(rt, "processingStart"), jsInvoker),
      bridging::fromJs<decltype(types.processingEnd)>(rt, value.getProperty(rt, "processingEnd"), jsInvoker),
      bridging::fromJs<decltype(types.interactionId)>(rt, value.getProperty(rt, "interactionId"), jsInvoker),
      bridging::fromJs<decltype(types.fetchStart)>(rt, value.getProperty(rt, "fetchStart"), jsInvoker),
      bridging::fromJs<decltype(types.requestStart)>(rt, value.getProperty(rt, "requestStart"), jsInvoker),
      bridging::fromJs<decltype(types.connectStart)>(rt, value.getProperty(rt, "connectStart"), jsInvoker),
      bridging::fromJs<decltype(types.connectEnd)>(rt, value.getProperty(rt, "connectEnd"), jsInvoker),
      bridging::fromJs<decltype(types.responseStart)>(rt, value.getProperty(rt, "responseStart"), jsInvoker),
      bridging::fromJs<decltype(types.responseEnd)>(rt, value.getProperty(rt, "responseEnd"), jsInvoker),
      bridging::fromJs<decltype(types.responseStatus)>(rt, value.getProperty(rt, "responseStatus"), jsInvoker),
      bridging::fromJs<decltype(types.contentType)>(rt, value.getProperty(rt, "contentType"), jsInvoker),
      bridging::fromJs<decltype(types.encodedBodySize)>(rt, value.getProperty(rt, "encodedBodySize"), jsInvoker),
      bridging::fromJs<decltype(types.decodedBodySize)>(rt, value.getProperty(rt, "decodedBodySize"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }
  static double entryTypeToJs(jsi::Runtime &rt, decltype(types.entryType) value) {
    return bridging::toJs(rt, value);
  }
  static double startTimeToJs(jsi::Runtime &rt, decltype(types.startTime) value) {
    return bridging::toJs(rt, value);
  }
  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }
  static double processingStartToJs(jsi::Runtime &rt, decltype(types.processingStart) value) {
    return bridging::toJs(rt, value);
  }
  static double processingEndToJs(jsi::Runtime &rt, decltype(types.processingEnd) value) {
    return bridging::toJs(rt, value);
  }
  static double interactionIdToJs(jsi::Runtime &rt, decltype(types.interactionId) value) {
    return bridging::toJs(rt, value);
  }
  static double fetchStartToJs(jsi::Runtime &rt, decltype(types.fetchStart) value) {
    return bridging::toJs(rt, value);
  }
  static double requestStartToJs(jsi::Runtime &rt, decltype(types.requestStart) value) {
    return bridging::toJs(rt, value);
  }
  static double connectStartToJs(jsi::Runtime &rt, decltype(types.connectStart) value) {
    return bridging::toJs(rt, value);
  }
  static double connectEndToJs(jsi::Runtime &rt, decltype(types.connectEnd) value) {
    return bridging::toJs(rt, value);
  }
  static double responseStartToJs(jsi::Runtime &rt, decltype(types.responseStart) value) {
    return bridging::toJs(rt, value);
  }
  static double responseEndToJs(jsi::Runtime &rt, decltype(types.responseEnd) value) {
    return bridging::toJs(rt, value);
  }
  static double responseStatusToJs(jsi::Runtime &rt, decltype(types.responseStatus) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String contentTypeToJs(jsi::Runtime &rt, decltype(types.contentType) value) {
    return bridging::toJs(rt, value);
  }
  static double encodedBodySizeToJs(jsi::Runtime &rt, decltype(types.encodedBodySize) value) {
    return bridging::toJs(rt, value);
  }
  static double decodedBodySizeToJs(jsi::Runtime &rt, decltype(types.decodedBodySize) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "entryType", bridging::toJs(rt, value.entryType, jsInvoker));
    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
    if (value.processingStart) {
      result.setProperty(rt, "processingStart", bridging::toJs(rt, value.processingStart.value(), jsInvoker));
    }
    if (value.processingEnd) {
      result.setProperty(rt, "processingEnd", bridging::toJs(rt, value.processingEnd.value(), jsInvoker));
    }
    if (value.interactionId) {
      result.setProperty(rt, "interactionId", bridging::toJs(rt, value.interactionId.value(), jsInvoker));
    }
    if (value.fetchStart) {
      result.setProperty(rt, "fetchStart", bridging::toJs(rt, value.fetchStart.value(), jsInvoker));
    }
    if (value.requestStart) {
      result.setProperty(rt, "requestStart", bridging::toJs(rt, value.requestStart.value(), jsInvoker));
    }
    if (value.connectStart) {
      result.setProperty(rt, "connectStart", bridging::toJs(rt, value.connectStart.value(), jsInvoker));
    }
    if (value.connectEnd) {
      result.setProperty(rt, "connectEnd", bridging::toJs(rt, value.connectEnd.value(), jsInvoker));
    }
    if (value.responseStart) {
      result.setProperty(rt, "responseStart", bridging::toJs(rt, value.responseStart.value(), jsInvoker));
    }
    if (value.responseEnd) {
      result.setProperty(rt, "responseEnd", bridging::toJs(rt, value.responseEnd.value(), jsInvoker));
    }
    if (value.responseStatus) {
      result.setProperty(rt, "responseStatus", bridging::toJs(rt, value.responseStatus.value(), jsInvoker));
    }
    if (value.contentType) {
      result.setProperty(rt, "contentType", bridging::toJs(rt, value.contentType.value(), jsInvoker));
    }
    if (value.encodedBodySize) {
      result.setProperty(rt, "encodedBodySize", bridging::toJs(rt, value.encodedBodySize.value(), jsInvoker));
    }
    if (value.decodedBodySize) {
      result.setProperty(rt, "decodedBodySize", bridging::toJs(rt, value.decodedBodySize.value(), jsInvoker));
    }
    return result;
  }
};



template <typename T>
class JSI_EXPORT NativePerformanceCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "NativePerformanceCxx";

protected:
  NativePerformanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativePerformanceCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["now"] = MethodMetadata {.argCount = 0, .invoker = __now};
    methodMap_["timeOrigin"] = MethodMetadata {.argCount = 0, .invoker = __timeOrigin};
    methodMap_["reportMark"] = MethodMetadata {.argCount = 3, .invoker = __reportMark};
    methodMap_["reportMeasure"] = MethodMetadata {.argCount = 4, .invoker = __reportMeasure};
    methodMap_["getMarkTime"] = MethodMetadata {.argCount = 1, .invoker = __getMarkTime};
    methodMap_["clearMarks"] = MethodMetadata {.argCount = 1, .invoker = __clearMarks};
    methodMap_["clearMeasures"] = MethodMetadata {.argCount = 1, .invoker = __clearMeasures};
    methodMap_["getEntries"] = MethodMetadata {.argCount = 0, .invoker = __getEntries};
    methodMap_["getEntriesByName"] = MethodMetadata {.argCount = 2, .invoker = __getEntriesByName};
    methodMap_["getEntriesByType"] = MethodMetadata {.argCount = 1, .invoker = __getEntriesByType};
    methodMap_["getEventCounts"] = MethodMetadata {.argCount = 0, .invoker = __getEventCounts};
    methodMap_["getSimpleMemoryInfo"] = MethodMetadata {.argCount = 0, .invoker = __getSimpleMemoryInfo};
    methodMap_["getReactNativeStartupTiming"] = MethodMetadata {.argCount = 0, .invoker = __getReactNativeStartupTiming};
    methodMap_["createObserver"] = MethodMetadata {.argCount = 1, .invoker = __createObserver};
    methodMap_["getDroppedEntriesCount"] = MethodMetadata {.argCount = 1, .invoker = __getDroppedEntriesCount};
    methodMap_["observe"] = MethodMetadata {.argCount = 2, .invoker = __observe};
    methodMap_["disconnect"] = MethodMetadata {.argCount = 1, .invoker = __disconnect};
    methodMap_["takeRecords"] = MethodMetadata {.argCount = 2, .invoker = __takeRecords};
    methodMap_["getSupportedPerformanceEntryTypes"] = MethodMetadata {.argCount = 0, .invoker = __getSupportedPerformanceEntryTypes};
    methodMap_["clearEventCountsForTesting"] = MethodMetadata {.argCount = 0, .invoker = __clearEventCountsForTesting};
  }
  
private:
  static jsi::Value __now(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::now) == 1,
      "Expected now(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::now,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __timeOrigin(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::timeOrigin) == 1,
      "Expected timeOrigin(...) to have 1 parameters");
    return bridging::callFromJs<double>(rt, &T::timeOrigin,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __reportMark(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reportMark) == 4,
      "Expected reportMark(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::reportMark,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : jsi::Value(rt, args[2]));return jsi::Value::undefined();
  }

  static jsi::Value __reportMeasure(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::reportMeasure) == 5,
      "Expected reportMeasure(...) to have 5 parameters");
    bridging::callFromJs<void>(rt, &T::reportMeasure,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
      count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : jsi::Value(rt, args[3]));return jsi::Value::undefined();
  }

  static jsi::Value __getMarkTime(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getMarkTime) == 2,
      "Expected getMarkTime(...) to have 2 parameters");
    auto result = bridging::callFromJs<std::optional<double>>(rt, &T::getMarkTime,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
  }

  static jsi::Value __clearMarks(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::clearMarks) == 2,
      "Expected clearMarks(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::clearMarks,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __clearMeasures(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::clearMeasures) == 2,
      "Expected clearMeasures(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::clearMeasures,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)));return jsi::Value::undefined();
  }

  static jsi::Value __getEntries(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getEntries) == 1,
      "Expected getEntries(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getEntries,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getEntriesByName(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getEntriesByName) == 3,
      "Expected getEntriesByName(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getEntriesByName,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asNumber()));
  }

  static jsi::Value __getEntriesByType(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getEntriesByType) == 2,
      "Expected getEntriesByType(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getEntriesByType,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());
  }

  static jsi::Value __getEventCounts(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getEventCounts) == 1,
      "Expected getEventCounts(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getEventCounts,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getSimpleMemoryInfo(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getSimpleMemoryInfo) == 1,
      "Expected getSimpleMemoryInfo(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getSimpleMemoryInfo,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getReactNativeStartupTiming(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getReactNativeStartupTiming) == 1,
      "Expected getReactNativeStartupTiming(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getReactNativeStartupTiming,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __createObserver(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::createObserver) == 2,
      "Expected createObserver(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::createObserver,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));
  }

  static jsi::Value __getDroppedEntriesCount(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getDroppedEntriesCount) == 2,
      "Expected getDroppedEntriesCount(...) to have 2 parameters");
    return bridging::callFromJs<double>(rt, &T::getDroppedEntriesCount,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));
  }

  static jsi::Value __observe(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::observe) == 3,
      "Expected observe(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::observe,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __disconnect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::disconnect) == 2,
      "Expected disconnect(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::disconnect,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]));return jsi::Value::undefined();
  }

  static jsi::Value __takeRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::takeRecords) == 3,
      "Expected takeRecords(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::takeRecords,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());
  }

  static jsi::Value __getSupportedPerformanceEntryTypes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getSupportedPerformanceEntryTypes) == 1,
      "Expected getSupportedPerformanceEntryTypes(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getSupportedPerformanceEntryTypes,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __clearEventCountsForTesting(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::clearEventCountsForTesting) == 1,
      "Expected clearEventCountsForTesting(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::clearEventCountsForTesting,  static_cast<NativePerformanceCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};

} // namespace facebook::react
