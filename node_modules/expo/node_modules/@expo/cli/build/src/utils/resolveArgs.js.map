{"version":3,"sources":["../../../src/utils/resolveArgs.ts"],"sourcesContent":["import arg, { Spec } from 'arg';\n\nimport { replaceAllValues } from './array';\nimport { CommandError } from './errors';\n\n/**\n * Spec for extra arguments that can be string or boolean.\n * - `'--flag': Boolean` → accepts any value\n * - `'--flag': [Boolean, 'a', 'b']` → restricted to 'true', 'false', 'a', 'b'\n * - `'-f': '--flag'` → alias\n */\nexport type ExtraArgsSpec = Record<string, typeof Boolean | string | [typeof Boolean, ...string[]]>;\n\n/** Convert ExtraArgsSpec to arg.Spec (for validation) and extract allowedValues */\nfunction parseExtraArgMap(extraArgMap: ExtraArgsSpec): {\n  spec: arg.Spec;\n  allowedValues: Record<string, string[]>;\n} {\n  const spec: arg.Spec = {};\n  const allowedValues: Record<string, string[]> = {};\n\n  for (const [key, value] of Object.entries(extraArgMap)) {\n    if (typeof value === 'string') {\n      // Alias (e.g. '-f': '--flag')\n      spec[key] = value;\n    } else if (Array.isArray(value)) {\n      // Tuple [Boolean, ...strings] - Boolean is enforced by the type, but check at runtime too\n      const [first, ...stringValues] = value;\n      if (first !== Boolean) {\n        throw new CommandError(\n          'BAD_ARGS',\n          `Invalid extraArgMap spec for ${key}: first element must be Boolean`\n        );\n      }\n      spec[key] = Boolean;\n      allowedValues[key] = ['true', 'false', ...stringValues];\n    } else {\n      // Boolean - any value allowed\n      spec[key] = Boolean;\n    }\n  }\n\n  return { spec, allowedValues };\n}\n\n/** Split up arguments that are formatted like `--foo=bar` or `-f=\"bar\"` to `['--foo', 'bar']` */\nfunction splitArgs(args: string[]): string[] {\n  const result: string[] = [];\n\n  for (const arg of args) {\n    if (arg.startsWith('-')) {\n      const [key, ...props] = arg.split('=');\n      result.push(key);\n      if (props.length) {\n        result.push(props.join('='));\n      }\n    } else {\n      result.push(arg);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Enables the resolution of arguments that can either be a string or a boolean.\n *\n * @param argv arguments that were passed to the command.\n * @param rawArgMap base argument spec defining valid arguments and their types.\n * @param extraArgMap extra arguments and aliases that should be resolved as string or boolean.\n *   - `'--flag': Boolean` → accepts any value\n *   - `'--flag': [Boolean, 'a', 'b']` → restricted to 'true', 'false', 'a', 'b'\n *   - `'-f': '--flag'` → alias\n * @returns parsed arguments and project root.\n */\nexport async function resolveStringOrBooleanArgsAsync(\n  argv: string[],\n  rawArgMap: arg.Spec,\n  extraArgMap: ExtraArgsSpec\n) {\n  let args = splitArgs(argv);\n\n  const { spec: extraArgSpec, allowedValues } = parseExtraArgMap(extraArgMap);\n  const combinedSpec = { ...rawArgMap, ...extraArgSpec };\n\n  // Assert any missing arguments\n  assertUnknownArgs(combinedSpec, args);\n\n  // Collapse aliases into fully qualified arguments.\n  args = collapseAliases(combinedSpec, args);\n\n  // Filter out array-type arguments so _resolveStringOrBooleanArgs can process the rest.\n  // This is necessary because _resolveStringOrBooleanArgs can't handle array-type args like --platform.\n  const filteredArgs = filterOutArrayArgs(args, combinedSpec);\n\n  // Resolve all of the string or boolean arguments and the project root.\n  return _resolveStringOrBooleanArgs(combinedSpec, filteredArgs, allowedValues);\n}\n\n/**\n * Enables the resolution of boolean arguments that can be formatted like `--foo=true` or `--foo false`\n *\n * @param argv arguments that were passed to the command.\n * @param rawArgMap base argument spec defining valid arguments and their types.\n * @param extraArgMap extra arguments and aliases that should be resolved as string or boolean.\n * @returns parsed arguments and project root.\n */\nexport async function resolveCustomBooleanArgsAsync(\n  argv: string[],\n  rawArgMap: arg.Spec,\n  extraArgMap: ExtraArgsSpec\n) {\n  const results = await resolveStringOrBooleanArgsAsync(argv, rawArgMap, extraArgMap);\n\n  return {\n    ...results,\n    args: Object.fromEntries(\n      Object.entries(results.args).map(([key, value]) => {\n        // Skip aliases (e.g. '-f': '--flag') - only process actual flags\n        const extraArgValue = extraArgMap[key];\n        if (extraArgValue && typeof extraArgValue !== 'string') {\n          if (typeof value === 'string') {\n            if (!['true', 'false'].includes(value)) {\n              throw new CommandError(\n                'BAD_ARGS',\n                `Invalid boolean argument: ${key}=${value}. Expected one of: true, false`\n              );\n            }\n            return [key, value === 'true'];\n          }\n        }\n        return [key, value];\n      })\n    ),\n  };\n}\n\nexport function _resolveStringOrBooleanArgs(\n  arg: Spec,\n  args: string[],\n  allowedValues?: Record<string, string[]>\n) {\n  // Default project root, if a custom one is defined then it will overwrite this.\n  let projectRoot: string = '.';\n  // The resolved arguments.\n  const settings: Record<string, string | boolean | undefined> = {};\n\n  // Create a list of possible arguments, this will filter out aliases.\n  const possibleArgs = Object.entries(arg)\n    .filter(([, value]) => typeof value !== 'string')\n    .map(([key]) => key);\n\n  // Check if a value is allowed for a given flag\n  const isAllowedValue = (flag: string, value: string): boolean => {\n    if (!allowedValues || !allowedValues[flag]) {\n      return true; // No restrictions, allow any value\n    }\n    return allowedValues[flag].includes(value);\n  };\n\n  // Loop over arguments in reverse order so we can resolve if a value belongs to a flag.\n  for (let i = args.length - 1; i > -1; i--) {\n    const value = args[i];\n    // At this point we should have converted all aliases to fully qualified arguments.\n    if (value.startsWith('--')) {\n      // If we ever find an argument then it must be a boolean because we are checking in reverse\n      // and removing arguments from the array if we find a string.\n      // We don't override arguments that are already set\n      if (!(value in settings)) {\n        settings[value] = true;\n      }\n    } else {\n      // Get the previous argument in the array.\n      const nextValue = i > 0 ? args[i - 1] : null;\n      if (nextValue && possibleArgs.includes(nextValue) && isAllowedValue(nextValue, value)) {\n        // We don't override arguments that are already set\n        if (!(nextValue in settings)) {\n          settings[nextValue] = value;\n        }\n        i--;\n      } else if (\n        // If the last value is not a flag and it doesn't have a recognized flag before it (instead having a string value or nothing)\n        // then it must be the project root.\n        i ===\n        args.length - 1\n      ) {\n        projectRoot = value;\n      } else {\n        // This will asserts if two strings are passed in a row and not at the end of the line.\n        throw new CommandError('BAD_ARGS', `Unknown argument: ${value}`);\n      }\n    }\n  }\n\n  return {\n    args: settings,\n    projectRoot,\n  };\n}\n\n/** Convert all aliases to fully qualified flag names. */\nexport function collapseAliases(arg: Spec, args: string[]): string[] {\n  const aliasMap = getAliasTuples(arg);\n\n  for (const [arg, alias] of aliasMap) {\n    args = replaceAllValues(args, arg, alias);\n  }\n\n  // Assert if there are duplicate flags after we collapse the aliases.\n  // Skip array-type arguments (like --platform) which can have multiple values.\n  assertDuplicateArgs(args, aliasMap, arg);\n  return args;\n}\n\n/** Assert that the spec has unknown arguments. */\nexport function assertUnknownArgs(arg: Spec, args: string[]) {\n  const allowedArgs = Object.keys(arg);\n  const unknownArgs = args.filter((arg) => !allowedArgs.includes(arg) && arg.startsWith('-'));\n  if (unknownArgs.length > 0) {\n    throw new CommandError(`Unknown arguments: ${unknownArgs.join(', ')}`);\n  }\n}\n\nfunction getAliasTuples(arg: Spec): [string, string][] {\n  return Object.entries(arg).filter(([, value]) => typeof value === 'string') as [string, string][];\n}\n\n/** Filter out array-type arguments from the spec (and their values).\n * This is needed because _resolveStringOrBooleanArgs can't handle array args like --platform.\n */\nfunction filterOutArrayArgs(args: string[], spec: Spec): string[] {\n  // Get the set of flag names that are array types\n  const arrayFlags = new Set(\n    Object.entries(spec)\n      .filter(([, value]) => Array.isArray(value))\n      .map(([key]) => key)\n  );\n\n  if (arrayFlags.size === 0) {\n    return args;\n  }\n\n  const result: string[] = [];\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (arrayFlags.has(arg)) {\n      // Skip this flag and its value if it has one\n      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {\n        i++;\n      }\n    } else {\n      result.push(arg);\n    }\n  }\n  return result;\n}\n\n/** Asserts that a duplicate flag has been used, this naively throws without knowing if an alias or flag were used as the duplicate. */\nexport function assertDuplicateArgs(\n  args: string[],\n  argNameAliasTuple: [string, string][],\n  spec?: Spec\n) {\n  for (const [argName, argNameAlias] of argNameAliasTuple) {\n    // Skip array-type arguments (like --platform) which can have multiple values\n    if (spec && Array.isArray(spec[argNameAlias])) {\n      continue;\n    }\n    if (args.filter((a) => [argName, argNameAlias].includes(a)).length > 1) {\n      throw new CommandError(\n        'BAD_ARGS',\n        `Can only provide one instance of ${argName} or ${argNameAlias}`\n      );\n    }\n  }\n}\n\nexport function assertNonBooleanArg(argName: string, arg: any): asserts arg is string | string[] {\n  if (arg == null || typeof arg === 'boolean') {\n    throw new CommandError('BAD_ARGS', `Expected input for arg ${argName}`);\n  }\n}\n"],"names":["_resolveStringOrBooleanArgs","assertDuplicateArgs","assertNonBooleanArg","assertUnknownArgs","collapseAliases","resolveCustomBooleanArgsAsync","resolveStringOrBooleanArgsAsync","parseExtraArgMap","extraArgMap","spec","allowedValues","key","value","Object","entries","Array","isArray","first","stringValues","Boolean","CommandError","splitArgs","args","result","arg","startsWith","props","split","push","length","join","argv","rawArgMap","extraArgSpec","combinedSpec","filteredArgs","filterOutArrayArgs","results","fromEntries","map","extraArgValue","includes","projectRoot","settings","possibleArgs","filter","isAllowedValue","flag","i","nextValue","aliasMap","getAliasTuples","alias","replaceAllValues","allowedArgs","keys","unknownArgs","arrayFlags","Set","size","has","argNameAliasTuple","argName","argNameAlias","a"],"mappings":"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"}