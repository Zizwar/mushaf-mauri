{"version":3,"sources":["../../../../../src/start/server/metro/resolveLoader.ts"],"sourcesContent":["import type { RouteNode } from 'expo-router/build/Route';\nimport { type RouteInfo, type RoutesManifest } from 'expo-server/private';\n\n/**\n * Unified route information needed for loader execution\n */\nexport interface ResolvedLoaderRoute {\n  /** Path to the route file (relative or absolute). For static routes, this will point to the parent dynamic route */\n  file: string;\n  /** The pathname being rendered */\n  pathname: string;\n  /** Extracted URL parameters */\n  params: Record<string, string | string[]>;\n}\n\ntype FromRuntimeManifestRouteOptions = {\n  appDir: string;\n  serverManifest: RoutesManifest<RegExp>;\n};\n\n/**\n * Converts a `RouteNode` to a `ResolvedLoaderRoute` object using runtime manifest lookup\n */\nexport function fromRuntimeManifestRoute(\n  pathname: string,\n  route: RouteNode,\n  options: FromRuntimeManifestRouteOptions\n): ResolvedLoaderRoute | null {\n  // Skip internal routes (like `_sitemap` or `+not-found`)\n  if (route.internal) {\n    return null;\n  }\n\n  // For static routes that were generated from dynamic routes, we need to use the parent's\n  // context key to find the loader\n  // @see expo-router/src/loadStaticParamsAsync.ts\n  const contextKey =\n    route.dynamic === null && route.parentContextKey ? route.parentContextKey : route.contextKey;\n\n  if (!contextKey) {\n    return null;\n  }\n\n  // Find the server manifest route that matches this context key\n  const serverManifestRoute = options.serverManifest.htmlRoutes.find((r) => r.file === contextKey);\n\n  if (!serverManifestRoute) {\n    return null;\n  }\n\n  return {\n    file: serverManifestRoute.file,\n    pathname,\n    params: extractParams(pathname, serverManifestRoute),\n  };\n}\n\n/**\n * Converts a `RouteInfo` to a `ResolvedLoaderRoute` object using server manifest lookup\n */\nexport function fromServerManifestRoute(\n  pathname: string,\n  route: RouteInfo<RegExp>\n): ResolvedLoaderRoute | null {\n  if (route.generated) {\n    return null;\n  }\n\n  return {\n    file: route.file,\n    pathname,\n    params: extractParams(pathname, route),\n  };\n}\n\n/**\n * Extract URL parameters from a pathname using a route's named regex\n */\nfunction extractParams(\n  pathname: string,\n  route: RouteInfo<RegExp>\n): Record<string, string | string[]> {\n  const params: Record<string, string | string[]> = {};\n  const match = route.namedRegex.exec(pathname);\n  if (match?.groups) {\n    for (const [key, value] of Object.entries(match.groups)) {\n      const namedKey = route.routeKeys[key];\n      params[namedKey] = value;\n    }\n  }\n  return params;\n}\n"],"names":["fromRuntimeManifestRoute","fromServerManifestRoute","pathname","route","options","internal","contextKey","dynamic","parentContextKey","serverManifestRoute","serverManifest","htmlRoutes","find","r","file","params","extractParams","generated","match","namedRegex","exec","groups","key","value","Object","entries","namedKey","routeKeys"],"mappings":";;;;;;;;;;;IAuBgBA,wBAAwB;eAAxBA;;IAqCAC,uBAAuB;eAAvBA;;;AArCT,SAASD,yBACdE,QAAgB,EAChBC,KAAgB,EAChBC,OAAwC;IAExC,yDAAyD;IACzD,IAAID,MAAME,QAAQ,EAAE;QAClB,OAAO;IACT;IAEA,yFAAyF;IACzF,iCAAiC;IACjC,gDAAgD;IAChD,MAAMC,aACJH,MAAMI,OAAO,KAAK,QAAQJ,MAAMK,gBAAgB,GAAGL,MAAMK,gBAAgB,GAAGL,MAAMG,UAAU;IAE9F,IAAI,CAACA,YAAY;QACf,OAAO;IACT;IAEA,+DAA+D;IAC/D,MAAMG,sBAAsBL,QAAQM,cAAc,CAACC,UAAU,CAACC,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKR;IAErF,IAAI,CAACG,qBAAqB;QACxB,OAAO;IACT;IAEA,OAAO;QACLK,MAAML,oBAAoBK,IAAI;QAC9BZ;QACAa,QAAQC,cAAcd,UAAUO;IAClC;AACF;AAKO,SAASR,wBACdC,QAAgB,EAChBC,KAAwB;IAExB,IAAIA,MAAMc,SAAS,EAAE;QACnB,OAAO;IACT;IAEA,OAAO;QACLH,MAAMX,MAAMW,IAAI;QAChBZ;QACAa,QAAQC,cAAcd,UAAUC;IAClC;AACF;AAEA;;CAEC,GACD,SAASa,cACPd,QAAgB,EAChBC,KAAwB;IAExB,MAAMY,SAA4C,CAAC;IACnD,MAAMG,QAAQf,MAAMgB,UAAU,CAACC,IAAI,CAAClB;IACpC,IAAIgB,yBAAAA,MAAOG,MAAM,EAAE;QACjB,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACP,MAAMG,MAAM,EAAG;YACvD,MAAMK,WAAWvB,MAAMwB,SAAS,CAACL,IAAI;YACrCP,MAAM,CAACW,SAAS,GAAGH;QACrB;IACF;IACA,OAAOR;AACT"}