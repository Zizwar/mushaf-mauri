"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    fromRuntimeManifestRoute: function() {
        return fromRuntimeManifestRoute;
    },
    fromServerManifestRoute: function() {
        return fromServerManifestRoute;
    }
});
function fromRuntimeManifestRoute(pathname, route, options) {
    // Skip internal routes (like `_sitemap` or `+not-found`)
    if (route.internal) {
        return null;
    }
    // For static routes that were generated from dynamic routes, we need to use the parent's
    // context key to find the loader
    // @see expo-router/src/loadStaticParamsAsync.ts
    const contextKey = route.dynamic === null && route.parentContextKey ? route.parentContextKey : route.contextKey;
    if (!contextKey) {
        return null;
    }
    // Find the server manifest route that matches this context key
    const serverManifestRoute = options.serverManifest.htmlRoutes.find((r)=>r.file === contextKey);
    if (!serverManifestRoute) {
        return null;
    }
    return {
        file: serverManifestRoute.file,
        pathname,
        params: extractParams(pathname, serverManifestRoute)
    };
}
function fromServerManifestRoute(pathname, route) {
    if (route.generated) {
        return null;
    }
    return {
        file: route.file,
        pathname,
        params: extractParams(pathname, route)
    };
}
/**
 * Extract URL parameters from a pathname using a route's named regex
 */ function extractParams(pathname, route) {
    const params = {};
    const match = route.namedRegex.exec(pathname);
    if (match == null ? void 0 : match.groups) {
        for (const [key, value] of Object.entries(match.groups)){
            const namedKey = route.routeKeys[key];
            params[namedKey] = value;
        }
    }
    return params;
}

//# sourceMappingURL=resolveLoader.js.map