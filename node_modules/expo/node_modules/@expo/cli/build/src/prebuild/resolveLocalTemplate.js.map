{"version":3,"sources":["../../../src/prebuild/resolveLocalTemplate.ts"],"sourcesContent":["import type { ExpoConfig } from '@expo/config';\nimport fs from 'fs';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { packNpmTarballAsync, extractNpmTarballAsync } from '../utils/npm';\n\nconst debug = require('debug')('expo:prebuild:resolveLocalTemplate') as typeof console.log;\n\n/** Returns the `local-template` target path, only for the `expo/expo` monorepo */\nconst getMonorepoTemplatePath = async () => {\n  const cliPath = path.dirname(require.resolve('@expo/cli/package.json'));\n  const localTemplateOriginPath = path.join(cliPath, 'local-template');\n  try {\n    return await fs.promises.realpath(localTemplateOriginPath);\n  } catch {\n    return null;\n  }\n};\n\nexport async function resolveLocalTemplateAsync({\n  templateDirectory,\n  projectRoot,\n  exp,\n}: {\n  templateDirectory: string;\n  projectRoot: string;\n  exp: Pick<ExpoConfig, 'name'>;\n}): Promise<string> {\n  let templatePath: string;\n\n  // In the expo/expo monorepo only, we use `templates/expo-template-bare-minimum` directly\n  const monorepoTemplatePath = await getMonorepoTemplatePath();\n  if (monorepoTemplatePath) {\n    debug('Packing local template from expo-template-bare-minimum path:', monorepoTemplatePath);\n    try {\n      templatePath = await packNpmTarballAsync(monorepoTemplatePath);\n      debug('Using packed local template at:', templatePath);\n    } catch (error) {\n      // We're vocal here about an error, since we don't expect this to fail, and it's only for our monorepo\n      console.error(\n        `Failed to pack local expo-template-bare-minimum to be used as a prebuild template:\\n`,\n        error\n      );\n      throw error;\n    }\n  } else {\n    // The default is to use `expo/template.tgz` which exists in all published versions of it\n    templatePath = resolveFrom(projectRoot, 'expo/template.tgz');\n    debug('Using local template from Expo package:', templatePath);\n  }\n\n  const stream = fs.createReadStream(templatePath);\n  return await extractNpmTarballAsync(stream, {\n    cwd: templateDirectory,\n    name: exp.name,\n  });\n}\n"],"names":["resolveLocalTemplateAsync","debug","require","getMonorepoTemplatePath","cliPath","path","dirname","resolve","localTemplateOriginPath","join","fs","promises","realpath","templateDirectory","projectRoot","exp","templatePath","monorepoTemplatePath","packNpmTarballAsync","error","console","resolveFrom","stream","createReadStream","extractNpmTarballAsync","cwd","name"],"mappings":";;;;+BAoBsBA;;;eAAAA;;;;gEAnBP;;;;;;;gEACE;;;;;;;gEACO;;;;;;qBAEoC;;;;;;AAE5D,MAAMC,QAAQC,QAAQ,SAAS;AAE/B,gFAAgF,GAChF,MAAMC,0BAA0B;IAC9B,MAAMC,UAAUC,eAAI,CAACC,OAAO,CAACJ,QAAQK,OAAO,CAAC;IAC7C,MAAMC,0BAA0BH,eAAI,CAACI,IAAI,CAACL,SAAS;IACnD,IAAI;QACF,OAAO,MAAMM,aAAE,CAACC,QAAQ,CAACC,QAAQ,CAACJ;IACpC,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAeR,0BAA0B,EAC9Ca,iBAAiB,EACjBC,WAAW,EACXC,GAAG,EAKJ;IACC,IAAIC;IAEJ,yFAAyF;IACzF,MAAMC,uBAAuB,MAAMd;IACnC,IAAIc,sBAAsB;QACxBhB,MAAM,gEAAgEgB;QACtE,IAAI;YACFD,eAAe,MAAME,IAAAA,wBAAmB,EAACD;YACzChB,MAAM,mCAAmCe;QAC3C,EAAE,OAAOG,OAAO;YACd,sGAAsG;YACtGC,QAAQD,KAAK,CACX,CAAC,oFAAoF,CAAC,EACtFA;YAEF,MAAMA;QACR;IACF,OAAO;QACL,yFAAyF;QACzFH,eAAeK,IAAAA,sBAAW,EAACP,aAAa;QACxCb,MAAM,2CAA2Ce;IACnD;IAEA,MAAMM,SAASZ,aAAE,CAACa,gBAAgB,CAACP;IACnC,OAAO,MAAMQ,IAAAA,2BAAsB,EAACF,QAAQ;QAC1CG,KAAKZ;QACLa,MAAMX,IAAIW,IAAI;IAChB;AACF"}